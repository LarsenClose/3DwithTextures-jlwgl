/*  this class should be extended to provide
    an event-driven, graphical application

   The extending class should have its own constructor
   where things can be set up before the window is prepared,
   with a call to super( window title, width in pixels, height in pixels,
                          nanoseconds in a step )

   Override these methods:

   init:  do things to be done once at the begining after the window
          is ready to go

   display:  draw the game world

   processInputs:  scan InputInfo queue and process all waiting input events
                   with appropriate changes to game objects
    
   update:  advance the simulation one full time step

*/

//  LWJGL release = 3.0.0 build 90
//  (earlier LWJGL3 download failed---Sys class seems to have disappeared,
//   but the code wasn't using it, anyway;  a few other little changes)

import org.lwjgl.glfw.*;
import org.lwjgl.opengl.*;
 
import java.nio.ByteBuffer;
 
import static org.lwjgl.glfw.Callbacks.*;
import static org.lwjgl.glfw.GLFW.*;
import static org.lwjgl.opengl.GL11.*;
import static org.lwjgl.opengl.GL21.*;
import static org.lwjgl.opengl.GL33.*;
import static org.lwjgl.system.MemoryUtil.*;
 
public class Basic{
 

  // set to 2 for Retina displays like in AES 250, 1 on non-Retina displays
  public final static int RETINAFACTOR = 2;

  // We need to strongly reference callback instances.
  private GLFWKeyCallback keyCallback;
  private GLFWCursorPosCallback cursorPosCallback;
  private GLFWMouseButtonCallback mouseButtonCallback;
 
  // The window handle
  private long window;

  private String title;
  private int width, height; // in pixel units
  private int stepNumber;
  private long timeStep;   // amount of time in a step in nanoseconds

  private long startTime;
 
  private int mouseX, mouseY;  // current mouse cursor position

  // create window given title, size in pixels, step time in nanoseconds
  public Basic( String windowLabel, int pw, int ph, long timeInNanos )
  {
    title = windowLabel;
    width = pw;  height = ph;
    stepNumber = 0;

    timeStep = timeInNanos;
    startTime = System.nanoTime();
  }

  public void start() {
    try{
      setup();   // get window ready to go
      loop();
 
      // Release window and window callbacks
      glfwFreeCallbacks(window);
      glfwDestroyWindow(window);

    } finally {
      // Terminate GLFW
      glfwTerminate();
    }
  }// start
 
  private void setup()
  {
    // Initialize GLFW. Most GLFW functions will not work before doing this.
    if( !glfwInit() )
      throw new IllegalStateException("Unable to initialize GLFW");
 
// Note:  these 4 hints seem necessary (at least on my Mac) to
//        get OpenGL version 3.3, but may cause problems in Windows
//--------------------------------------------------
    // Configure the window, choosing OpenGL version
    // and the core profile and forward compatibility
    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);
    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);
    glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);
    glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);
//--------------------------------------------------

    glfwWindowHint(GLFW_VISIBLE, 0 ); // the window will stay hidden after creation
    glfwWindowHint(GLFW_RESIZABLE, 0 ); // the window will not be resizable

    // Get the usable resolution of the primary monitor
    /*  could use this to detect full screen size on any monitor
// doesn't work!
    GLFWVidMode vidmode = glfwGetVideoMode(glfwGetPrimaryMonitor());
    width = GLFWVidMode.width(vidmode);
    height = GLFWVidMode.height(vidmode);
System.out.println("width = " + width + " height = " + height );
    */

    // Create the window
    window = glfwCreateWindow(width, height, title, NULL, NULL);
    if( window == NULL )
      throw new RuntimeException("Failed to create the GLFW window");

    // Set up a key callback. 
    // It will be called every time a key is pressed, repeated or released.
    glfwSetKeyCallback(window, 
      keyCallback = new GLFWKeyCallback() 
      {
        public void invoke(long window, int key, 
                           int scancode, int action, 
                           int mods)
        {
          // whenever a key is pressed, the callback function
          // puts it in the InputInfo queue for processing later in an app
          InputInfo.add( new InputInfo( 'k', key, action, mods ) );
        }
      }
    );

    glfwSetCursorPosCallback( window,
       cursorPosCallback = new GLFWCursorPosCallback()
       {
         public void invoke(long window, double xpos, double ypos )
         {
           // whenever cursor moves, add input info
           InputInfo.add( new InputInfo( 'm', (int) Math.round(xpos),
                                              (int) Math.round(ypos) ) );
         }
       }
     );
 
    glfwSetMouseButtonCallback( window,
       mouseButtonCallback = new GLFWMouseButtonCallback()
       {
         public void invoke(long window, int button, int action, int mods )
         {
           // whenever mouse button is pressed, released, or repeated, make input info
           InputInfo.add( new InputInfo( 'b', button, action, mods ) );
         }
       }
    );

    glfwSetWindowPos( window, 0, 50 );
 
    // Make the OpenGL context current
    glfwMakeContextCurrent(window);

    // Enable v-sync
    glfwSwapInterval(1);

    glfwSetInputMode(window, GLFW_CURSOR, GLFW_CURSOR_NORMAL );

    // Make the window visible
    glfwShowWindow(window);

  }
 
  private final static int NUMDELAYSPERYIELD = 5;  // hope not important

  private void loop()
  {
    // This line is critical for LWJGL's interoperation with GLFW's
    // OpenGL context, or any context that is managed externally.
    // LWJGL detects the context that is current in the current thread,
    // creates the ContextCapabilities instance and makes the OpenGL
    // bindings available for use.
//    GLContext.createFromCurrent();

    GL.createCapabilities();
 
    // show version information
    System.out.println("OpenGL vendor: " + glGetString( GL_RENDERER ) );
    System.out.println("OpenGL version: " + glGetString( GL_VERSION ) );
    System.out.println("GLSL version: " + 
                         glGetString( GL20.GL_SHADING_LANGUAGE_VERSION ) );

    init();

    // Run the rendering loop until the window wants to close
    long prevTime = System.nanoTime();
    long overTime = 0L;

    int numDelays = 0;

    while( ! glfwWindowShouldClose(window) ) {
      stepNumber++;

      display();
      processInputs();
      update();

      long currentTime = System.nanoTime();

      // figure time spent on this step already in nanoseconds
      long elapsedTime = currentTime - prevTime;

      long sleepTime = timeStep - elapsedTime - overTime;

      if( sleepTime > 0 )
      {// have some time to sleep
        try{
          Thread.sleep( sleepTime/1000000L ); // sleep this many milliseconds
        }
        catch(InterruptedException ie)
        {}
        prevTime = System.nanoTime();  // will be the new before step time
        // figure how much too long it took with overhead from sleeping
        overTime = prevTime - currentTime - sleepTime;
      }
      else
      {// step took longer than timeStep
        overTime = 0L;
        prevTime = System.nanoTime();
        numDelays++;

        if( numDelays >= NUMDELAYSPERYIELD )
        {// give another thread a chance
          Thread.yield();
          numDelays = 0;
        }
      }
      
      glfwSwapBuffers(window); // swap the color buffers
 
      // Poll for window events. The key callback above will only be
      // invoked during this call.
      glfwPollEvents();
    }
  }
 
  // ---------------------- methods that can be called in app  -------

  public int getStepNumber()
  {
    return stepNumber;
  }

  // return time from start of application
  // in milliseconds
  public long getTime()
  {
    return (System.nanoTime() - startTime) / 1000000L;
  }

  public double getTimeStep()
  {
    return timeStep/1e9;  //convert from nanoseconds to seconds
  }

  public void restartStepNumbering()
  {
    stepNumber = 0;
  }

  public int getMouseX()
  {
    return mouseX;
  }

  public int getMouseY()
  {
    return mouseY;
  }

  public int getPixelWidth()
  {
    return width;
  }

  public int getPixelHeight()
  {
    return height;
  }

  // ---------------------- methods that can and should be overridden -------

  protected void init()
  {
    // Set the clear color
    glClearColor(0.0f, 1.0f, 0.0f, 0.0f);
  }

  protected void processInputs()
  {
    while( InputInfo.size() > 0 )
    {// process next input info
      InputInfo info = InputInfo.get();
      System.out.println( info );
    }
  }

  protected void update() {
  }

  protected void display() {
    // clear the framebuffer to the set clear color
    // and default depth value
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); 
  }

  public static void main(String[] args)
  {
    Basic t = new Basic( "Basic App (should be extended)", 800, 600, 33333333L );
    t.start();
  }
 
}
import java.util.Scanner;
import java.util.ArrayList;

import java.nio.FloatBuffer;


public class Block {



   // return total number of vertices in all the triangles
   // in the list of blocks
   public static int getNumVerts(ArrayList<Block> list) {
      int count = 0;
      for (int k = 0; k < list.size(); k++) {
         count += list.get(k).numVerts();
      }
      return count;
   }

   // instance fields
   private String kind;
   private Triple[] verts; // all model vertices of the triangles
   private int[][] tris; // indices into verts of each triangle
   public ArrayList<Mat4> matrices;
   protected static double eps = Util.collTol; // just for typing convenience
   private static int nextId = 0;
   private int id;

   protected double cx, cy, cz; // current center point of the block
   protected double sx, sy, sz; // current size of block

   // june25: remember how oriented, changing so cursor is at reference point
   protected int ori; // is one of 0 (+x) 90 (+y) 180 (-x) 270 (-y)
   protected double refX, refY, refZ; // keep reference point updated to match center

   protected Triple vel; // current translational velocity for this block
   // other physics stuff will be added later:

   // texture info for the 6 faces
   protected int[] textures; // texture number for each face in standard order
   // front, right, back, left, top, bottom
   protected double[] texScales; // each kind of block has its own texture
   // scaling

   protected ArrayList<Request> requests;
   // protected ArrayList<Request> requests;

   // universal attributes
   protected boolean supported;

   // transformations:
   Mat4 scale, scaleHalf, rotate, translate, translateOne, translateTwo, translateTre, translateFour, translateFive;

   public Block(Scanner input) {
      nextId++;
      id = nextId;

      kind = input.next();
      input.nextLine();

      if (kind.equals("groundBox") || kind.equals("clownBox") || kind.equals("groundBoxed")
            || kind.equals("sierpinskiBox") || kind.equals("pyraBox")) {
         if (kind.equals("pyraBox") || kind.equals("sierpinskiBox")) {
            // build the model vertices
            verts = new Triple[5];
            // x y z <=> 4 2 1
            verts[0] = new Triple(-1, -1, 0);
            verts[1] = new Triple(-1, 1, 0);
            verts[2] = new Triple(1, -1, 0);
            verts[3] = new Triple(1, 1, 0);
            verts[4] = new Triple(0, 0, 1);

            // build the triangles
            tris = new int[][] { { 0, 1, 2 }, { 2, 3, 1 }, // bottom
                  { 0, 1, 4 }, { 0, 2, 4 }, { 1, 3, 4 }, { 3, 2, 4 }, { 2, 3, 4 },

            };
         } // pyramid

         else if (kind.equals("groundBox") || kind.equals("clownBox")) {

            // build the model vertices
            verts = new Triple[8];
            // x y z <=> 4 2 1
            verts[0] = new Triple(-1, -1, -1);
            verts[1] = new Triple(-1, -1, 1);
            verts[2] = new Triple(-1, 1, -1);
            verts[3] = new Triple(-1, 1, 1);
            verts[4] = new Triple(1, -1, -1);
            verts[5] = new Triple(1, -1, 1);
            verts[6] = new Triple(1, 1, -1);
            verts[7] = new Triple(1, 1, 1);

            // build the triangles
            tris = new int[][] { { 0, 4, 5 }, { 0, 5, 1 }, // front face
                  { 4, 6, 7 }, { 4, 7, 5 }, // right
                  { 2, 3, 7 }, { 2, 7, 6 }, // back
                  { 2, 0, 1 }, { 2, 1, 3 }, // left
                  { 2, 6, 4 }, { 2, 4, 0 }, // bottom
                  { 1, 5, 7 }, { 1, 7, 3 } }; // top

         } // box
      }

      else {// unknown
         System.out.println("Unknown kind of block");
         System.exit(1);
      }

      // get transformation data and build matrices
      double sx = input.nextDouble(), sy = input.nextDouble(), sz = input.nextDouble();
      input.nextLine();
      scale = Mat4.scale(sx, sy, sz);

      double theta = input.nextDouble(), ax = input.nextDouble(), ay = input.nextDouble(), az = input.nextDouble();
      input.nextLine();
      rotate = Mat4.rotate(theta, ax, ay, az);

      double tx = input.nextDouble(), ty = input.nextDouble(), tz = input.nextDouble();
      input.nextLine();
      translate = Mat4.translate(tx, ty, tz);

   }

   // send the position and color data for all the
   // vertices in all the triangles
   public void sendData(FloatBuffer positionBuffer, FloatBuffer colorBuffer) {
      Mat4 matrix = translate.mult(rotate.mult(scale));

      for (int k = 0; k < tris.length; k++) {
         for (int j = 0; j < 3; j++) {
            Vec4 v = matrix.mult(verts[tris[k][j]].toVec4());
            v.sendData(positionBuffer);
            if (kind.equals("clownBox")) {
               Colors.sendData(k, colorBuffer);
            } else if (kind.equals("pyraBox")) {
               Colors.sendData(k + 12, colorBuffer);
            } else if (kind.equals("sierpinskiBox")) {
               Colors.sendData(k + 12, colorBuffer);
            } else if (kind.equals("groundBox")) {
               Colors.sendData(19, colorBuffer);
            }
         }
      }
   }

   public int numVerts() {
      return tris.length * 3;
   }

   public void draw(ArrayList<Triangle> list) {

      Vertex v1, v2, v3; // convenience

      // front face (index 0) --------------------

      v1 = new Vertex(cx - sx, cy - sy, cz - sz, 0, 0);
      v2 = new Vertex(cx + sx, cy - sy, cz - sz, 2 * sx / texScales[0], 0);
      v3 = new Vertex(cx + sx, cy - sy, cz + sz, 2 * sx / texScales[0], 2 * sz / texScales[0]);
      list.add(new Triangle(v1, v2, v3, textures[0]));

      v1 = new Vertex(cx - sx, cy - sy, cz - sz, 0, 0);
      v2 = new Vertex(cx + sx, cy - sy, cz + sz, 2 * sx / texScales[0], 2 * sz / texScales[0]);
      v3 = new Vertex(cx - sx, cy - sy, cz + sz, 0, 2 * sz / texScales[0]);
      list.add(new Triangle(v1, v2, v3, textures[0]));

      // right face (index 1) --------------------

      v1 = new Vertex(cx + sx, cy - sy, cz - sz, 0, 0);
      v2 = new Vertex(cx + sx, cy + sy, cz - sz, 2 * sy / texScales[1], 0);
      v3 = new Vertex(cx + sx, cy + sy, cz + sz, 2 * sy / texScales[1], 2 * sz / texScales[1]);
      list.add(new Triangle(v1, v2, v3, textures[1]));

      v1 = new Vertex(cx + sx, cy - sy, cz - sz, 0, 0);
      v2 = new Vertex(cx + sx, cy + sy, cz + sz, 2 * sy / texScales[1], 2 * sz / texScales[1]);
      v3 = new Vertex(cx + sx, cy - sy, cz + sz, 0, 2 * sz / texScales[1]);
      list.add(new Triangle(v1, v2, v3, textures[1]));

      // back face (index 2) --------------------

      v1 = new Vertex(cx + sx, cy + sy, cz - sz, 0, 0);
      v2 = new Vertex(cx - sx, cy + sy, cz - sz, 2 * sx / texScales[2], 0);
      v3 = new Vertex(cx - sx, cy + sy, cz + sz, 2 * sx / texScales[2], 2 * sz / texScales[2]);
      list.add(new Triangle(v1, v2, v3, textures[2]));

      v1 = new Vertex(cx + sx, cy + sy, cz - sz, 0, 0);
      v2 = new Vertex(cx - sx, cy + sy, cz + sz, 2 * sx / texScales[2], 2 * sz / texScales[2]);
      v3 = new Vertex(cx + sx, cy + sy, cz + sz, 0, 2 * sz / texScales[2]);
      list.add(new Triangle(v1, v2, v3, textures[2]));

      // left face (index 3) --------------------

      v1 = new Vertex(cx - sx, cy + sy, cz - sz, 0, 0);
      v2 = new Vertex(cx - sx, cy - sy, cz - sz, 2 * sy / texScales[3], 0);
      v3 = new Vertex(cx - sx, cy - sy, cz + sz, 2 * sy / texScales[3], 2 * sz / texScales[3]);
      list.add(new Triangle(v1, v2, v3, textures[3]));

      v1 = new Vertex(cx - sx, cy + sy, cz - sz, 0, 0);
      v2 = new Vertex(cx - sx, cy - sy, cz + sz, 2 * sy / texScales[3], 2 * sz / texScales[3]);
      v3 = new Vertex(cx - sx, cy + sy, cz + sz, 0, 2 * sz / texScales[3]);
      list.add(new Triangle(v1, v2, v3, textures[3]));

      // top face (index 4) --------------------

      v1 = new Vertex(cx - sx, cy - sy, cz + sz, 0, 0);
      v2 = new Vertex(cx + sx, cy - sy, cz + sz, 2 * sx / texScales[4], 0);
      v3 = new Vertex(cx + sx, cy + sy, cz + sz, 2 * sx / texScales[4], 2 * sy / texScales[4]);
      list.add(new Triangle(v1, v2, v3, textures[4]));

      v1 = new Vertex(cx - sx, cy - sy, cz + sz, 0, 0);
      v2 = new Vertex(cx + sx, cy + sy, cz + sz, 2 * sx / texScales[4], 2 * sy / texScales[4]);
      v3 = new Vertex(cx - sx, cy + sy, cz + sz, 0, 2 * sy / texScales[4]);
      list.add(new Triangle(v1, v2, v3, textures[4]));

      // bottom face (index 5) --------------------

      v1 = new Vertex(cx - sx, cy + sy, cz - sz, 0, 0);
      v2 = new Vertex(cx + sx, cy + sy, cz - sz, 2 * sx / texScales[5], 0);
      v3 = new Vertex(cx + sx, cy - sy, cz - sz, 2 * sx / texScales[5], 2 * sy / texScales[5]);
      list.add(new Triangle(v1, v2, v3, textures[5]));

      v1 = new Vertex(cx - sx, cy + sy, cz - sz, 0, 0);
      v2 = new Vertex(cx + sx, cy - sy, cz - sz, 2 * sx / texScales[5], 2 * sy / texScales[5]);
      v3 = new Vertex(cx - sx, cy - sy, cz - sz, 0, 2 * sy / texScales[5]);
      list.add(new Triangle(v1, v2, v3, textures[5]));
   }

}
/*
   camera to set frustum and lookAt
   matrices
*/

import java.util.Scanner;
import java.nio.FloatBuffer;

import org.lwjgl.opengl.*;

public class Camera {

   private Triple e, c, eN; 
   private double azi, aziN;  // rotation of camera in x-y plane
   private double alt, altN;  // rotation of camera from x-y plane
   private double near, nearN;  // distance from e to c

   private Mat4 frustum, lookAt;
   private int frustumLoc, lookAtLoc;  // handles to uniform variables
   private FloatBuffer frustumBuffer, lookAtBuffer;

   public Camera( Triple eye, double azimuth, double altitude, double dist ) {
      createBuffers();
      compute( eye, azimuth, altitude, dist );
   }

   public Camera( Scanner input ) {
      createBuffers();

      Triple eye = new Triple( input );
      double azimuth = input.nextDouble();
      double altitude = input.nextDouble();
      double dist = input.nextDouble();
      input.nextLine();
      input.nextLine();

      compute( eye, azimuth, altitude, dist );
   }

   private void createBuffers() {
      frustumBuffer = Util.createFloatBuffer( 16 );
      lookAtBuffer = Util.createFloatBuffer( 16 );
   }

   private void compute( Triple eye, double azimuth, double altitude, double dist ) {
      e = eye;         // "e" for lookAt matrix
      azi = azimuth;   // use to compute c
      alt = altitude;
      near = dist;        // n for frustum matrix

      double alpha = Math.toRadians( azi );
      double beta = Math.toRadians( alt );

      double cosBeta = Math.cos( beta );
      double sinBeta = Math.sin( beta );
      double cosAlpha = Math.cos( alpha );
      double sinAlpha = Math.sin( alpha );

       
      // "c" for lookAt matrix
      c = new Triple( e.x + cosBeta * near * cosAlpha, 
                      e.y + cosBeta * near * sinAlpha,
                      e.z + near * sinBeta 
                    );

   }

   public void turn( double dazi ) {
      azi += dazi;
      compute( e, azi, alt, near );
   }

   public void tilt( double dalt ) {
      alt += dalt;
      compute( e, azi, alt, near );
   }

   public void zoom( double v ) {
      near += v;
      compute( e, azi, alt, near );
   }

   public void move( double dx, double dy, double dz ) {
      e = new Triple( e.x + dx, e.y + dy, e.z + dz );
      compute( e, azi, alt, near );
   }

   public void mapUpdate( int hp1 ) {
      // eN = new Triple( 50, 50, 250 );
      // aziN = 90;
      // altN = -89;
      // nearN = 1;

      // compute( eN, aziN, altN, nearN );
      // Camera.update( hp1);
      // gluLookAt(0.0, 0.0, 3.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0);

            // set up handles to uniform variables
            frustumLoc = GL20.glGetUniformLocation( hp1, "frustum" );
            lookAtLoc = GL20.glGetUniformLocation( hp1, "lookAt" );
      
            // create the matrices
            frustum = Mat4.frustum( -1, 1, -1, 1, near, 1000*near );
            lookAt = Mat4.lookAt( e, c, Triple.up );
      
            // create buffer versions of the matrices
            frustum.toBuffer( frustumBuffer );
            lookAt.toBuffer( lookAtBuffer );
      
            // sends data for uniforms to GPU
            GL20.glUniformMatrix4fv( frustumLoc, true, frustumBuffer );
            GL20.glUniformMatrix4fv( lookAtLoc, true, lookAtBuffer );
   }

   public void info(  ) {
       System.out.println("e is " + e + "azi is " + azi + "alt is " + alt + "near is " + near); 
   }


   // given camera data azi, alt, d, e, c
   // update frustum and lookAt and send uniform
   // variable data to GPU
   public void update( int hp1 ) {

      // set up handles to uniform variables
      frustumLoc = GL20.glGetUniformLocation( hp1, "frustum" );
      lookAtLoc = GL20.glGetUniformLocation( hp1, "lookAt" );

      // create the matrices
      frustum = Mat4.frustum( -1, 1, -1, 1, near, 1000*near );
      lookAt = Mat4.lookAt( e, c, Triple.up );

      // create buffer versions of the matrices
      frustum.toBuffer( frustumBuffer );
      lookAt.toBuffer( lookAtBuffer );

      // sends data for uniforms to GPU
      GL20.glUniformMatrix4fv( frustumLoc, true, frustumBuffer );
      GL20.glUniformMatrix4fv( lookAtLoc, true, lookAtBuffer );

   }

}


import org.lwjgl.glfw.*;
import org.lwjgl.opengl.*;

import static org.lwjgl.glfw.Callbacks.*;
import static org.lwjgl.glfw.GLFW.*; // just for the key constants
import static org.lwjgl.system.MemoryUtil.*;

import java.io.File;
import java.nio.FloatBuffer;
import java.nio.ByteBuffer;
import java.nio.IntBuffer;

import java.util.ArrayList;
import java.util.Scanner;
import java.io.*;
import javax.swing.JFileChooser;

public class CastlesIntheDigital extends Basic {

  private static final int MAX = 1000;

  public static void main(String[] args) {
    if (args.length != 1) {
      System.out.println("Usage:  j CastlesIntheDigital <input file name>");
      System.exit(1);
    }

    CastlesIntheDigital app = new CastlesIntheDigital("Chapter 7", 1000, 500, 30, args[0]);
    app.start();
  } // main

  // instance variables

  private Pic pic;
  private Shader v1, f1;
  private int hp1; // handle for the GLSL program
  private int textureId1;

  private int vao; // handle to the vertex array object
  private int vaoHandle1, vboPositionHandle1, vboTexCoordsHandle1;
  private int vaoHandle2, vboPositionHandle2, vboTexCoordsHandle2;
  private int colorLoc; 
  private int hp2;

  private ArrayList<Block> blocks;

  private Soups permSoups;


  private int positionHandle, colorHandle, textHandle;
  private FloatBuffer positionBuffer, colorBuffer, textureBuffer;
  private Camera camera, mapView;

  // construct basic application with given title, pixel width and height
  // of drawing area, and frames per second
  public CastlesIntheDigital(String appTitle, int pw, int ph, int fps, String fileName) {
    super(appTitle, pw, ph, (long) ((1.0 / fps) * 1000000000));

    // pic = new Pic("image", "Pictures/" + greenfire);

    // read camera data and triangle data from data file with given name
    try {
      Pic.init();

      Util.init();     // set up single large buffer for soup use

      Scanner input = new Scanner(new File(fileName));

      mapView = new Camera(new Triple(50, 50, 100), 0, -90.00001, 2);
      camera = new Camera(input);

      blocks = new ArrayList<Block>();
      int number = input.nextInt();
      input.nextLine();
      input.nextLine();
      for (int k = 0; k < number; k++) {
        blocks.add(new Block(input));
        input.nextLine();
      }
    } catch (Exception e) {
      System.out.println("Failed to open and load from [" + fileName + "]");
      System.exit(1);
    }
  }

  private double[] positions = { -1.0, -1.0, 0.5,
    1.0, -1.0, 0.5,
    1.0, 1.0, 0.5,
    -1.0, -1.0, 0.5,
     1.0, 1.0, 0.5,
     -1.0, 1.0, 0.5  };
// texture coordinates for each vertex
private double[] texCoords = { 0.0, 0.0,
    1.0, 0.0,
    1.0, 1.0,
    0.0, 0.0,
    1.0, 1.0,
    0.0, 1.0  };

  protected void init() {

    OpenGL.init();
    OpenGL.useRegularProgram();

    ArrayList<Triangle> perm = new ArrayList<Triangle>();
    // activate all the textures
    for (int k = 0; k < Pic.size(); k++) {
      OpenGL.loadTexture(Pic.get(k));
      System.out.println("activated texture number " + k);
    }

        // set up fixed for display once and for all
    permSoups = new Soups( Pic.size() );
    permSoups.addTris( perm );
    permSoups.sortByTexture();

        // System.out.println("finished creating the permSoups");

    // String vertexShaderCode =
    // "#version 330 core\n"
    // + "layout (location = 0 ) in vec3 vertexPosition;\n"
    // + "layout (location = 1 ) in vec3 vertexColor;\n"
    // + "out vec3 color;\n"
    // + "uniform mat4 frustum;\n"
    // + "uniform mat4 lookAt;\n"
    // + "void main(void)\n"
    // + "{\n"
    // + " color = vertexColor;\n"
    // + " gl_Position = frustum * lookAt * vec4( vertexPosition, 1.0);\n"
    // + "}\n";

    // System.out.println("Vertex shader:\n" + vertexShaderCode + "\n\n");

    // v1 = new Shader("vertex", vertexShaderCode);

    /// addition start
    String vertexShaderCode1 = "#version 330 core\n" + "layout (location = 0) in vec3 vertexPosition;\n"
        + "layout (location = 1) in vec2 vertexTexCoord;\n" + "out vec2 texCoord;\n" + "void main(void)\n" + "{\n"
        + "  texCoord = vertexTexCoord;\n" + "  gl_Position = vec4(vertexPosition,1.0);\n" + "}\n";

    System.out.println("Vertex shader for textured triangles:\n" + vertexShaderCode1 + "\n\n");

    v1 = new Shader("vertex", vertexShaderCode1);

    String fragmentShaderCode1 = "#version 330 core\n" + "in vec2 texCoord;\n"
        + "layout (location = 0) out vec4 fragColor;\n" + "uniform sampler2D texture1;\n" + "void main(void)\n" + "{\n"
        + "  fragColor = texture( texture1, texCoord );\n" + "}\n";

    System.out.println("Fragment shader for textured triangles:\n" + fragmentShaderCode1 + "\n\n");

    f1 = new Shader("fragment", fragmentShaderCode1);

    /// addition end

    // String fragmentShaderCode =
    // "#version 330 core\n"
    // + "in vec3 color;\n"
    // + "layout (location = 0 ) out vec4 fragColor;\n"
    // + "void main(void)\n"
    // + "{\n"
    // + " fragColor = vec4(color, 1.0 );\n"
    // + "}\n";

    // System.out.println("Fragment shader:\n" + fragmentShaderCode + "\n\n");

    // f1 = new Shader("fragment", fragmentShaderCode);

    hp1 = GL20.glCreateProgram();

    Util.error("after create program");
    System.out.println("program handle is " + hp1);

    GL20.glAttachShader(hp1, v1.getHandle());
    Util.error("after attach vertex shader to program");

    GL20.glAttachShader(hp1, f1.getHandle());
    Util.error("after attach fragment shader to program");

    GL20.glLinkProgram(hp1);
    Util.error("after link program");

    FloatBuffer positionData = Util.arrayToBuffer(positions);
    FloatBuffer texCoordData = Util.arrayToBuffer(texCoords);

    positionData.rewind();
    texCoordData.rewind();

    // set up vertex array object
    vaoHandle1 = GL30.glGenVertexArrays();
    Util.error("after generate single vertex array");
    System.out.println("vertex array handle: " + vaoHandle1);
    GL30.glBindVertexArray(vaoHandle1);
    Util.error("after bind vao");

    // set up the position VBO
    vboPositionHandle1 = GL15.glGenBuffers();
    Util.error("after generate position buffer handle");
    System.out.println("position handle: " + vboPositionHandle1);
    GL15.glBindBuffer(GL15.GL_ARRAY_BUFFER, vboPositionHandle1);
    Util.error("after bind positionHandle");
    GL15.glBufferData(GL15.GL_ARRAY_BUFFER, positionData, GL15.GL_STATIC_DRAW);
    Util.error("after set position data");
    GL20.glEnableVertexAttribArray(0); // position
    Util.error("after enable attrib 0");
    GL20.glVertexAttribPointer(0, 3, GL11.GL_FLOAT, false, 0, 0);
    Util.error("after do position vertex attrib pointer");

    // set up the tex coords VBO
    vboTexCoordsHandle1 = GL15.glGenBuffers();
    Util.error("after generate tex coords buffer handle");
    System.out.println("tex coords handle: " + vboTexCoordsHandle1);
    GL15.glBindBuffer(GL15.GL_ARRAY_BUFFER, vboTexCoordsHandle1);
    Util.error("after bind tex coords Handle");
    GL15.glBufferData(GL15.GL_ARRAY_BUFFER, texCoordData, GL15.GL_STATIC_DRAW);
    Util.error("after set tex coords data");
    GL20.glEnableVertexAttribArray(1); // tex coords
    Util.error("after enable attrib 1");
    GL20.glVertexAttribPointer(1, 2, GL11.GL_FLOAT, false, 0, 0);
    Util.error("after do tex coords attrib pointer");

    while (this.pic.getHeight() != 0){
    // set up texture
    GL13.glActiveTexture( GL13.GL_TEXTURE0 );
           Util.error("after activate texture 0");
    textureId1 = GL11.glGenTextures();
           Util.error("after generate texture id " + textureId1 );
    GL11.glBindTexture( GL11.GL_TEXTURE_2D, textureId1 );
           Util.error("after bind texture");
    GL11.glTexImage2D( GL11.GL_TEXTURE_2D, 0, GL11.GL_RGBA,
                       pic.getWidth(), pic.getHeight(), 0,   
      // with this image is messed up:  pic.getHeight(), pic.getWidth(), 0, 
                       GL11.GL_RGBA, GL11.GL_UNSIGNED_BYTE, 
                       pic.getData() );
           Util.error("after set data");
    GL11.glTexParameteri( GL11.GL_TEXTURE_2D, GL11.GL_TEXTURE_MAG_FILTER,
                           GL11.GL_NEAREST );
           Util.error("after set mag filter");
    GL11.glTexParameteri( GL11.GL_TEXTURE_2D, GL11.GL_TEXTURE_MIN_FILTER,
                           GL11.GL_NEAREST );
           Util.error("after set min filter");

    }
    // send texture sampler as a uniform
    int loc = GL20.glGetUniformLocation(hp1, "texture1");
    Util.error("after get uniform location for texture1");
    System.out.println("got loc for texture1: " + loc);
    GL20.glUniform1i(loc, 0); // connect texture1 to texture unit 0
    Util.error("after set value of texture1");


    //----------------------------------------------


    // set up vertex array object
    vaoHandle2 = GL30.glGenVertexArrays();
    Util.error("after generate single vertex array");
    System.out.println("vertex array handle: " + vaoHandle2);
    GL30.glBindVertexArray(vaoHandle2);
    Util.error("after bind vao");

    // set up the position VBO
    vboPositionHandle2 = GL15.glGenBuffers();
    Util.error("after generate position buffer handle");
    System.out.println("position handle: " + vboPositionHandle2);

    GL15.glBindBuffer(GL15.GL_ARRAY_BUFFER, vboPositionHandle1);
    Util.error("after bind positionHandle");
    GL15.glBufferData(GL15.GL_ARRAY_BUFFER, positionData, GL15.GL_STATIC_DRAW);
    Util.error("after set position data");
    GL20.glEnableVertexAttribArray(0); // position
    Util.error("after enable attrib 0");
    GL20.glVertexAttribPointer(0, 3, GL11.GL_FLOAT, false, 0, 0);
    Util.error("after do position vertex attrib pointer");

    // set up the tex coords VBO
    vboTexCoordsHandle1 = GL15.glGenBuffers();
    Util.error("after generate tex coords buffer handle");
    System.out.println("tex coords handle: " + vboTexCoordsHandle1);
    GL15.glBindBuffer(GL15.GL_ARRAY_BUFFER, vboTexCoordsHandle1);
    Util.error("after bind tex coords Handle");
    GL15.glBufferData(GL15.GL_ARRAY_BUFFER, texCoordData, GL15.GL_STATIC_DRAW);
    Util.error("after set tex coords data");
    GL20.glEnableVertexAttribArray(1); // tex coords
    Util.error("after enable attrib 1");
    GL20.glVertexAttribPointer(1, 2, GL11.GL_FLOAT, false, 0, 0);
    Util.error("after do tex coords attrib pointer");

    // // send color as a uniform
    // colorLoc = GL20.glGetUniformLocation(hp2, "color");
    // Util.error("after get uniform location for color");
    // System.out.println("got loc for color: " + colorLoc);

    // set the background color
    GL11.glClearColor(1.0f, 1.0f, 1.0f, 0.0f);

    // enable depth test
    GL11.glEnable(GL11.GL_DEPTH_TEST);
    GL11.glClearDepth(1.0f);
    // GL11.glDepthFunc(GL11.GL_LESS);

    // create vertex buffer objects and their handles one at a time
    positionHandle = GL15.glGenBuffers();
    colorHandle = GL15.glGenBuffers();
    textHandle = GL15.glGenBuffers();
    System.out.println("have position handle " + positionHandle + " and color handle " + colorHandle
        + " and texture handle " + textHandle);

    // create the buffers (data doesn't matter so much, just the size)
    positionBuffer = Util.createFloatBuffer(MAX * 3 * 3);
    colorBuffer = Util.createFloatBuffer(MAX * 3 * 3);
    textureBuffer = Util.createFloatBuffer(MAX * 3 * 3);

    // set up the text buffer
    textHandle = GL15.glGenBuffers();
    Util.error("after generate tex coords buffer handle");
    System.out.println("tex coords handle: " + textHandle);
    GL15.glBindBuffer(GL15.GL_ARRAY_BUFFER, textHandle);
    Util.error("after bind tex coords Handle");
    GL15.glBufferData(GL15.GL_ARRAY_BUFFER, texCoordData, GL15.GL_STATIC_DRAW);
    Util.error("after set tex coords data");
    GL20.glEnableVertexAttribArray(1); // tex coords
    Util.error("after enable attrib 1");
    GL20.glVertexAttribPointer(1, 2, GL11.GL_FLOAT, false, 0, 0);
    Util.error("after do tex coords attrib pointer");

    // set up texture

    GL13.glActiveTexture(GL13.GL_TEXTURE0);
    Util.error("after activate texture 0");
    System.out.println("texture unit 0 constant is " + GL13.GL_TEXTURE0);
    pic.setTextureId(GL11.glGenTextures());
    System.out.println("generated texture name is " + pic.getTextureId());
    Util.error("after generate texture id " + pic.getTextureId());
    GL11.glBindTexture(GL11.GL_TEXTURE_2D, pic.getTextureId());
    Util.error("after bind texture");
    GL11.glTexImage2D(GL11.GL_TEXTURE_2D, 0, GL11.GL_RGBA, pic.getWidth(), pic.getHeight(), 0,
        // with this image is messed up: pic.getHeight(), pic.getWidth(), 0,
        GL11.GL_RGBA, GL11.GL_UNSIGNED_BYTE, pic.getData());
    Util.error("after set data");

    GL11.glTexParameteri(GL11.GL_TEXTURE_2D, GL11.GL_TEXTURE_MAG_FILTER, GL11.GL_NEAREST);
    Util.error("after set mag filter");
    GL11.glTexParameteri(GL11.GL_TEXTURE_2D, GL11.GL_TEXTURE_MIN_FILTER, GL11.GL_NEAREST);
    Util.error("after set min filter");

    // send texture sampler as a uniform
  //   int loc = GL20.glGetUniformLocation(hp1, "texture1");
  //   Util.error("after get uniform location for texture1");
  //   System.out.println("got loc for texture1: " + loc);
  //   GL20.glUniform1i(loc, 0); // connect texture1 to texture unit 0
  //   Util.error("after set value of texture1");
  // }
  }

  protected void processInputs() {
    // process all waiting input events
    while (InputInfo.size() > 0) {
      InputInfo info = InputInfo.get();

      if (info.kind == 'k' && (info.action == GLFW_PRESS || info.action == GLFW_REPEAT)) {
        int code = info.code;
        boolean debug = false;

        if (code == GLFW_KEY_A) { // look left
          camera.turn(3);
          if (debug)
            mapView.turn(3);
        } else if (code == GLFW_KEY_D) { // look right
          camera.turn(-3);
          if (debug)
            mapView.turn(-3);
        } else if (code == GLFW_KEY_Q) { // pan vision down
          camera.tilt(-3);
          if (debug)
            mapView.tilt(-3);
        } else if (code == GLFW_KEY_E) { // pan vision up
          camera.tilt(3);
          if (debug)
            mapView.tilt(3);
        } else if (code == GLFW_KEY_LEFT) { // strafe left relative to body orientation
          camera.move(-1, 0, 0);
          if (debug)
            mapView.move(-1, 0, 0);
        } else if (code == GLFW_KEY_RIGHT) { // strafe left relative to body orientation
          camera.move(1, 0, 0);
          if (debug)
            mapView.move(1, 0, 0);
        } else if (code == GLFW_KEY_UP) { // forward
          camera.move(0, 1, 0);
          if (debug)
            mapView.move(0, 1, 0);
        } else if (code == GLFW_KEY_DOWN) { // backward
          camera.move(0, -1, 0);
          if (debug)
            mapView.move(0, -1, 0);
        } else if (code == GLFW_KEY_W) { // up
          camera.move(0, 0, 1);
          if (debug)
            mapView.move(0, 0, 1);
        } else if (code == GLFW_KEY_S) { // down
          camera.move(0, 0, -1);
          if (debug)
            mapView.move(0, 0, -1);
        } else if (code == GLFW_KEY_R) { // down

        }
      } // input event is a key
      else if (info.kind == 'm') { // mouse moved
        // System.out.println( info );
      } else if (info.kind == 'b') { // button action
        System.out.println(info);
        System.out.println(" updates info ");
        camera.update(hp1);
        camera.info();

        mapView.mapUpdate(hp1);
        mapView.info();
      }
    } // loop to process all input events
  }

  // hide retina display issue from ourselves
  private void setViewport(int left, int bottom, int width, int height) {
    // Note: the Util.retinaDisplay constant adjusts for
    // whether have Mac retina display (double pixels, I guess)
    // or not
    GL11.glViewport(Util.retinaDisplay * left, Util.retinaDisplay * bottom, Util.retinaDisplay * width,
        Util.retinaDisplay * height);
  }

  protected void display() {
    super.display(); // just clears the color and depth buffers

    GL20.glUseProgram(hp1);
    Util.error("after use program");

    // activate vao
    GL30.glBindVertexArray(vaoHandle1);
    Util.error("after bind vao");

    // System.out.println( getStepNumber() );

    sendData();
    map();
    update();
    permSoups.draw();
  }

  protected void update() {
    camera.update(hp1); // updates and sends frustum and lookAt

    setViewport(0, 0, 500, 500);
    GL11.glDrawArrays(GL11.GL_TRIANGLES, 0, Block.getNumVerts(blocks));
    Util.error("after draw arrays");
  }

  protected void map() {
    mapView.mapUpdate(hp1);

    setViewport(500, 0, 500, 500);
    GL11.glDrawArrays(GL11.GL_TRIANGLES, 0, Block.getNumVerts(blocks));
    Util.error("after draw arrays");
  }

  // protected void mapIt() {
  // map view
  // camera.map();
  // setViewport( 500, 0, 250, 500 );
  // GL11.glDrawArrays( GL11.GL_TRIANGLES, 0, Block.getNumVerts( blocks ) );
  // Util.error("after draw arrays");
  // }

  private void sendData() {

    // delete previous handle and binding
    // before doing a new one
    if (vao != -1) {
      GL30.glBindVertexArray(0);
      GL30.glDeleteVertexArrays(vao);
    }

    // using convenience form that produces one vertex array handle
    vao = GL30.glGenVertexArrays();
    Util.error("after generate single vertex array");
    GL30.glBindVertexArray(vao);
    Util.error("after bind the vao");
    // System.out.println("vao is " + vao );

    // connect data to the VBO's

    // actually get the data in positionBuffer, colorBuffer):

    positionBuffer.rewind();
    colorBuffer.rewind();
    textureBuffer.rewind();

    for (int k = 0; k < blocks.size(); k++) {
      blocks.get(k).sendData(positionBuffer, textureBuffer);
    }
    positionBuffer.rewind();
    colorBuffer.rewind();
    textureBuffer.rewind();

    // Util.showBuffer("position buffer: ", positionBuffer );
    // positionBuffer.rewind();
    // Util.showBuffer("color buffer: ", colorBuffer ); colorBuffer.rewind();

    // now connect the buffers
    GL15.glBindBuffer(GL15.GL_ARRAY_BUFFER, positionHandle);
    Util.error("after bind positionHandle");
    GL15.glBufferData(GL15.GL_ARRAY_BUFFER, positionBuffer, GL15.GL_STATIC_DRAW);
    Util.error("after set position data");

    GL15.glBindBuffer(GL15.GL_ARRAY_BUFFER, colorHandle);
    Util.error("after bind colorHandle");
    GL15.glBufferData(GL15.GL_ARRAY_BUFFER, colorBuffer, GL15.GL_STATIC_DRAW);
    Util.error("after set color data");

    GL15.glBindBuffer(GL15.GL_ARRAY_BUFFER, textHandle);
    Util.error("after bind textHandle");
    GL15.glBufferData(GL15.GL_ARRAY_BUFFER, textHandle, GL15.GL_STATIC_DRAW);
    Util.error("after set texture data");

    // enable the vertex array attributes
    GL20.glEnableVertexAttribArray(0); // position
    Util.error("after enable attrib 0");
    GL20.glEnableVertexAttribArray(1); // color
    Util.error("after enable attrib 1");
    GL20.glEnableVertexAttribArray(2); // texture
    Util.error("after enable attrib 2");

    // map index 0 to the position buffer
    GL15.glBindBuffer(GL15.GL_ARRAY_BUFFER, positionHandle);
    Util.error("after bind position buffer");
    GL20.glVertexAttribPointer(0, 3, GL11.GL_FLOAT, false, 0, 0);
    Util.error("after do position vertex attrib pointer");

    // map index 1 to the color buffer
    GL15.glBindBuffer(GL15.GL_ARRAY_BUFFER, colorHandle);
    Util.error("after bind color buffer");
    GL20.glVertexAttribPointer(1, 3, GL11.GL_FLOAT, false, 0, 0);
    Util.error("after do color vertex attrib pointer");

    // map index 2 to the texture buffer
    GL15.glBindBuffer(GL15.GL_ARRAY_BUFFER, textHandle);
    Util.error("after bind text buffer");
    GL20.glVertexAttribPointer(1, 3, GL11.GL_FLOAT, false, 0, 0);
    Util.error("after do texture vertex attrib pointer");
  } // sendData

  // given an array with data in it and an allocated buffer,
  // overwrite buffer contents with array data
  private void sendArrayToBuffer(float[] array, FloatBuffer buffer) {
    buffer.rewind();
    for (int k = 0; k < array.length; k++) {
      buffer.put(array[k]);
    }
  } // sendArrayToBuffer
} // CastlesIntheDigital
/*
   holds a bunch of colors
   for convenience
*/

import java.util.ArrayList;
import java.nio.FloatBuffer;

public class Colors {

   private static ArrayList<Triple> standardColors = init();

   // private static ArrayList<Triple> pyraColors = initPyro();

   private static ArrayList<Triple> init() {
      ArrayList<Triple> colors = new ArrayList<Triple>();

      colors.add(new Triple(1, 0, 0)); // 0 = red
      colors.add(new Triple(0, 1, 0)); // 1 = green
      colors.add(new Triple(0, 0, 1)); // 2 = blue
      colors.add(new Triple(1, 1, 0)); // 3 = yellow
      colors.add(new Triple(1, 0, 1)); // 4 = magenta
      colors.add(new Triple(0, 1, 1)); // 5 = cyan
      colors.add(new Triple(1, 0.5, 0)); // 6 = orange
      colors.add(new Triple(1, 0, 0.5)); // 7
      colors.add(new Triple(0, 1, 0.5)); // 8
      colors.add(new Triple(0.5, 1, 0)); // 9
      colors.add(new Triple(0.5, 0, 1)); // 10
      colors.add(new Triple(0, 0.5, 1)); // 11
      colors.add(new Triple(0, 1, .247)); // pryabase
      colors.add(new Triple(0, 1, .247)); // pyrabase
      colors.add(new Triple(1, .278, .612)); // pyraface
      colors.add(new Triple(.208, .710, 1)); // pyraface
      colors.add(new Triple(.558, 1, 1)); // pyrafaca
      colors.add(new Triple(.735, 0, 1)); // pyraface
      colors.add(new Triple(.51, 1.0, 0.92)); // 18 = pale green
      colors.add(new Triple(0,.444,0)); // 19 = black
      return colors;
   }

   // private static ArrayList<Triple> initPyro() {
   // ArrayList<Triple> colors = new ArrayList<Triple>();
   // colors.add( new Triple( .451,0.02,0.09) );
   // colors.add( new Triple( .451,0.02,0.09) );
   // colors.add( new Triple( .957,.271,.376 ) );
   // colors.add( new Triple( .267,.82,.875 ) );
   // colors.add( new Triple( .196,.643,.655 ) );
   // colors.add( new Triple( .118,.439,.412 ) );

   // return colors;
   // }

   public static void sendData(int k, FloatBuffer buffer) {
      standardColors.get(k).sendData(buffer);
   }

   // public static void sendDataPyra( int k, FloatBuffer buffer ) {
   // pyraColors.get(k).sendData( buffer );
   // }

}
/*  instances of this class represent
    input events

    the class provides a single queue
    for input events
*/

import java.util.ArrayList;

public class InputInfo
{
  //------------------- the input info queue -----------------------------
  // inefficiency of the queue is unimportant
  // so keep it simple
  private static ArrayList<InputInfo> queue = new ArrayList<InputInfo>();

  public static void add( InputInfo info )
  {
    queue.add( info );
  }

  public static int size()
  {
    return queue.size();
  }

  public static InputInfo get()
  {
    InputInfo info = queue.get( 0 );
    queue.remove( 0 );
    return info;
  }

  //------------------- individual InputInfo -----------------------------

  public char kind;  // the kind of input event
  public int code;  // the particular key or button that was used like GLFW_KEY_A is 65
  public int action;  // press, repeat, release
  public int mods;  // 1=shift, 2=control, 4=alt/option, can do several
  public int mouseX, mouseY;  // mouse cursor position

  public String toString()
  {
    if( kind == 'k' )
      return "[key #: " + code + " action: " + action +
             " mods: " + mods + "]";
    else if( kind == 'm' )
      return "[mouse moved to " + mouseX + " " + mouseY + "]";
    else if( kind == 'b' )
      return "[mouse button " + code + " action: " + action + " mods: " + mods + "]";
    else
      return "unknown kind of InputInfo";
  }

  // construct info for key or mouse press,release,repeat
  public InputInfo( char knd, int source, int act, int shifts )
  {
    kind = knd;
    code = source;
    action = act;
    mods = shifts;
  }

  // construct info for mouse move
  public InputInfo( char knd, int x, int y )
  {
    kind = knd;
    mouseX = x;  mouseY = y;
  }

}
import java.util.Scanner;
import java.nio.FloatBuffer;

public class Mat4 {
   private double[][] a;

   private double[][] data;

   public Mat4(double a11, double a12, double a13, double a14, double a21, double a22, double a23, double a24,
         double a31, double a32, double a33, double a34, double a41, double a42, double a43, double a44) {
      a = new double[4][4];
      a[0][0] = a11;
      a[0][1] = a12;
      a[0][2] = a13;
      a[0][3] = a14;
      a[1][0] = a21;
      a[1][1] = a22;
      a[1][2] = a23;
      a[1][3] = a24;
      a[2][0] = a31;
      a[2][1] = a32;
      a[2][2] = a33;
      a[2][3] = a34;
      a[3][0] = a41;
      a[3][1] = a42;
      a[3][2] = a43;
      a[3][3] = a44;
   }

   public  Mat4(double[][] temp) {
      a = new double[4][4];
      for (int r = 0; r < 4; r++)
         for (int c = 0; c < 4; c++) {
            a[r][c] = temp[r][c];
         }
   }

   public  Mat4(Scanner input) {
      data = new double[4][4];
      for (int r = 0; r < 4; r++)
         for (int c = 0; c < 4; c++) {
            data[r][c] = input.nextDouble();
         }
   }

   public static Mat4 identity() {
      return new Mat4(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
   }

   public static Mat4 translate(double a, double b, double c) {
      return new Mat4(1, 0, 0, a, 0, 1, 0, b, 0, 0, 1, c, 0, 0, 0, 1);
   }

   public static Mat4 scale(double a, double b, double c) {
      return new Mat4(a, 0, 0, 0, 0, b, 0, 0, 0, 0, c, 0, 0, 0, 0, 1);
   }

   public static Mat4 rotate(double theta, double x, double y, double z) {
      // normalize [x,y,z]
      double len = Math.sqrt(x * x + y * y + z * z);
      x /= len;
      y /= len;
      z /= len;

      double c = Math.cos(Math.toRadians(theta));
      double s = Math.sin(Math.toRadians(theta));

      return new Mat4(x * x * (1 - c) + c, x * y * (1 - c) - z * s, x * z * (1 - c) + y * s, 0, y * x * (1 - c) + z * s,
            y * y * (1 - c) + c, y * z * (1 - c) - x * s, 0, z * x * (1 - c) - y * s, z * y * (1 - c) + x * s,
            z * z * (1 - c) + c, 0, 0, 0, 0, 1);
   }

   public static Mat4 frustum(double l, double r, double b, double t, double n, double f) {
      return new Mat4((2 * n) / (r - l), 0, (r + l) / (r - l), 0, 0, (2 * n) / (t - b), (t + b) / (t - b), 0, 0, 0,
            -(f + n) / (f - n), -(2 * f * n) / (f - n), 0, 0, -1, 0);
   }

   public static Mat4 parralelProj(double l, double r, double b, double t, double n, double f) {
      return new Mat4(2 / (r - l), 0, 0, -(r + l) / (r - l), 0, 2 / (t - b), 0, -(t + b) / (t - b), 0, 0, -2 / (f - n),
            -(f + n) / (f - n), 0, 0, 0, 1);
   }

   public static Mat4 ortho(double l, double r, double b, double t, double n, double f) {
      return new Mat4(2 / (r - l), 0, 0, -(r + l) / (r - l), 0, 2 / (t - b), 0, -(t + b) / (t - b), 0, 0, -2 / (f - n),
            -(f + n) / (f - n), 0, 0, 0, 1);
   }

   public static Mat4 lookAt(Triple e, Triple c, Triple up) {
      Triple n = c.minus(e);
      n = n.normalize();
      Triple r = n.cross(up);
      r = r.normalize();
      Triple w = r.cross(n);
      w = w.normalize();

      Mat4 trans = Mat4.translate(-e.x, -e.y, -e.z);
      Mat4 rotate = new Mat4(r.x, r.y, r.z, 0, w.x, w.y, w.z, 0, -n.x, -n.y, -n.z, 0, 0, 0, 0, 1);

      Mat4 lookAt = rotate.mult(trans);

      return lookAt;
   }

   public static Mat4 lookAt(double eyex, double eyey, double eyez, double cx, double cy, double cz, double ux,
         double uy, double uz) {
      Triple e = new Triple(eyex, eyey, eyez);
      Triple c = new Triple(cx, cy, cz);
      Triple u = new Triple(ux, uy, uz);

      Triple n = c.subtract(e);
      Triple r = n.crossProduct(u);
      Triple w = r.crossProduct(n);
      n = n.normalized();
      r = r.normalized();
      w = w.normalized();

      Mat4 translate = new Mat4(1, 0, 0, -e.x, 0, 1, 0, -e.y, 0, 0, 1, -e.z, 0, 0, 0, 1);
      Mat4 rotate = new Mat4(r.x, r.y, r.z, 0, w.x, w.y, w.z, 0, -n.x, -n.y, -n.z, 0, 0, 0, 0, 1);
      Mat4 lookAt = rotate.mult(translate);
      return lookAt;
   }

   public Mat4 mult( Mat4 m ){
      double[][] temp = new double[4][4];
      for( int r=0; r<4; r++ )
        for( int c=0; c<4; c++ ){
          // form temp[r][c]
          temp[r][c] = 0;
          for( int k=0; k<4; k++ )
            temp[r][c] += a[r][k] * m.a[k][c];
        }
      return new Mat4( temp );    
    }
    


   public Vec4 mult(Vec4 p) {
      Vec4 q = new Vec4();
      for (int r = 0; r < 4; r++) {
         q.data[r] = 0;
         for (int c = 0; c < 4; c++) {
            q.data[r] += data[r][c] * p.data[c];
         }
      }
      return q;
   }

     // multiply 3 vector v
  // by upper 3 by 3 portion of this matrix
  // (only works for some matrices, including
  //  rotation matrices)
  public Triple mult( Triple v ) {
   return new Triple( a[0][0]*v.x + a[0][1]*v.y + a[0][2]*v.z,
                      a[1][0]*v.x + a[1][1]*v.y + a[1][2]*v.z,
                      a[2][0]*v.x + a[2][1]*v.y + a[2][2]*v.z );
}

// multiply 3 vector v as [x,y,z]
// by upper 3 by 3 portion of this matrix
// (only works for some matrices, including
//  rotation matrices)
public Triple mult( double x, double y, double z ) {
   return new Triple( a[0][0]*x + a[0][1]*y + a[0][2]*z,
                      a[1][0]*x + a[1][1]*y + a[1][2]*z,
                      a[2][0]*x + a[2][1]*y + a[2][2]*z );
}


   // fill buffer with components of this matrix
   // in ROW major order (row by row, rather than
   // column by column), then transpose when
   // do glUniform
   public void toBuffer(FloatBuffer buffer) {
      buffer.rewind();
      for (int r = 0; r < 4; r++) {
         for (int c = 0; c < 4; c++) {
            buffer.put((float) data[r][c]);
         }
      }
      buffer.rewind();
   }



   public String toString(){
      String s = "\n";
      for( int r=0; r<4; r++ ){
        for( int c=0; c<4; c++ ){
          s += Util.nice( a[r][c], 12, 5 );
        }
        s += "\n";
      }
      return s;
    }



     // convert this matrix a into handy column major
  // float[] and then make it a FloatBuffer
  public FloatBuffer toBuffer(){
   float[] fa = new float[16];

   int index = 0;

   for( int c=0; c<4; c++ )
     for( int r=0; r<4; r++ )
     {
       fa[index] = (float) a[r][c];
       index++;
     }

   return Util.arrayToBuffer( fa );
 }

   // public String toString() {
   //    String s = "";
   //    for (int r = 0; r < 4; r++) {
   //       for (int c = 0; c < 4; c++) {
   //          s += String.format("%12.5f", data[r][c]);
   //       }
   //       s += "\n";
   //    }
   //    return s;
   // }

   public static void main(String[] args) {
      Mat4 persp = Mat4.frustum(-3, 3, -2, 2, 1, 100);
      System.out.println(persp);

      Vec4 lbn = new Vec4(-3, -2, -1), rtf = new Vec4(300, 200, -100);
      Vec4 p = persp.mult(lbn);
      System.out.println("frustum * lbn = " + p);

      p = persp.mult(rtf);
      System.out.println("frustum * rtf = " + p);
      p = p.perspDiv();
      System.out.println("after persp div = " + p);

   }

}
/*
  encapsulate some desired behaviors
  of OpenGL
  (everything not handled
   elsewhere)

  I started to put in "splash screen" rendering
  but decided to use existing camera facilities
  instead.  Left the code in case might be useful
  later, but DON'T count on it---unfinished and
  not tested at all!!!
*/

import org.lwjgl.glfw.*;
import org.lwjgl.opengl.*;

import java.nio.ByteBuffer;
import java.nio.FloatBuffer;
import java.nio.IntBuffer;

import static org.lwjgl.glfw.Callbacks.*;
import static org.lwjgl.glfw.GLFW.*;
import static org.lwjgl.system.MemoryUtil.*;

import java.util.Scanner;
import java.io.File;

public class OpenGL{

  // handles for normal rendering:
  private static Shader v1, f1;
  private static int hp1, hp2;

  // private static Program p1;S

  // handles for splash screen rendering:
  // [not finished]
  // private static Shader v2, f2;
  // private static int hp2;
  // private static Program p2;

  public static void init()
  {

    // set up shaders for regular rendering of triangles:

    String vertexShaderCode =
//----------------------------------------------------------------------
"#version 330 core\n"+
"layout (location = 0 ) in vec3 vertexPosition;\n"+
"layout (location = 1 ) in vec2 vertexTexCoord;\n"+
"out vec2 texCoord;\n"+
"uniform mat4 proj;\n"+
"uniform mat4 view;\n"+
"void main(void)\n"+
"{\n"+
"  texCoord = vertexTexCoord;\n"+
"  gl_Position = proj * view * vec4( vertexPosition, 1.0);\n"+
"}\n";
//----------------------------------------------------------------------

    System.out.println("Vertex shader:\n" + vertexShaderCode + "\n\n" );

    v1 = new Shader( "vertex", vertexShaderCode );

    String fragmentShaderCode =
//----------------------------------------------------------------------
"#version 330 core\n"+
"in vec2 texCoord;\n"+
"layout (location = 0 ) out vec4 fragColor;\n"+
"uniform sampler2D texture1;\n"+
"void main(void)\n"+
"{\n"+
"  fragColor = texture( texture1, texCoord );\n"+
"}\n";

    System.out.println("Fragment shader:\n" + fragmentShaderCode + "\n\n" );

    f1 = new Shader( "fragment", fragmentShaderCode );

    hp1 = GL20.glCreateProgram();
         Util.error("after create program");
         System.out.println("program handle is " + hp1 );

    GL20.glAttachShader( hp1, v1.getHandle() );
         Util.error("after attach vertex shader to program");

    GL20.glAttachShader( hp1, f1.getHandle() );
         Util.error("after attach fragment shader to program");

    GL20.glLinkProgram( hp1 );
         Util.error("after link program" );

    GL20.glUseProgram( hp1 );
         Util.error("after use program");

   // ******************************************************************

    // set up shaders for splash screen rendering of triangles:

    vertexShaderCode =
//----------------------------------------------------------------------
"#version 330 core\n"+
"layout (location = 0) in vec3 vertexPosition;\n"+
"layout (location = 1) in vec2 vertexTexCoord;\n"+
"out vec2 texCoord;\n"+
"void main(void)\n"+
"{\n"+
"  texCoord = vertexTexCoord;\n"+
"  gl_Position = vec4(vertexPosition,1.0);\n"+
"}\n";
//----------------------------------------------------------------------

    System.out.println("Splash screen vertex shader:\n" + vertexShaderCode + "\n\n" );

    // v2 = new Shader( "vertex", vertexShaderCode );

    fragmentShaderCode =
//----------------------------------------------------------------------
"#version 330 core\n"+
"in vec2 texCoord;\n"+
"layout (location = 0) out vec4 fragColor;\n"+
"uniform sampler2D texture1;\n"+
"void main(void)\n"+
"{\n"+
"  fragColor = texture( texture1, texCoord );\n"+
"}\n";
//----------------------------------------------------------------------

    System.out.println("Splash screen Fragment shader:\n" + fragmentShaderCode + "\n\n" );

    // f2 = new Shader( "fragment", fragmentShaderCode );

    // hp2 = GL20.glCreateProgram();
    //      Util.error("after create program");
    //      System.out.println("program handle is " + hp2 );

    // GL20.glAttachShader( hp2, v2.getHandle() );
    //      Util.error("after attach vertex shader to program");

    // GL20.glAttachShader( hp2, f2.getHandle() );
    //      Util.error("after attach fragment shader to program");

    // GL20.glLinkProgram( hp2 );

    
    // enable depth buffering
    GL11.glEnable( GL11.GL_DEPTH_TEST );
    GL11.glClearDepth( 100.0f );
    GL11.glDepthFunc( GL11.GL_LESS );

  }// init

  
   // activate shaders for regular rendering:
   public static void useRegularProgram() {
      GL20.glUseProgram( hp1 );
         Util.error("after use regular program");
   }

  //  // activate shaders for splash screen rendering:
  //  public static void useSplashScreenProgram() {
  //     GL20.glUseProgram( hp2 );
  //        Util.error("after use splash program");
  //  }

  // allow any code to get location for a uniform variable
  // (used by Camera)
  public static int getUniformLoc( String name ){
    return GL20.glGetUniformLocation( hp1, name );
  }

  public static void setBackColor( int r, int g, int b ){
    GL11.glClearColor( r/255f, g/255f, b/255f, 1.0f );
  }

  public static void drawBackground(){
    GL11.glClear( GL11.GL_COLOR_BUFFER_BIT | GL11.GL_DEPTH_BUFFER_BIT );
  }

  public static void viewport( int px, int py, int pw, int ph ){
    final int f = Basic.RETINAFACTOR;
    GL11.glViewport( f*px, f*py, f*pw, f*ph );
  }

  // send Mat4 to uniform
  public static void sendUniformMatrix4( int loc, Mat4 matrix ){

    GL20.glUniformMatrix4fv( loc, false, matrix.toBuffer() );
        Util.error( "after sending matrix data with loc " + loc );
  }

  // load texture corresponding to pic
  public static void loadTexture( Pic pic ){

    // OpenGL promises that this will be same as like GL_TEXTURE13
    //   if textureNumber is 13
    GL13.glActiveTexture( GL13.GL_TEXTURE0 + pic.getIndex() );
           Util.error("after activate texture " + pic.getIndex() );

    pic.setTextureId( GL11.glGenTextures() );
           Util.error("after generate texture id " + pic.getTextureId() );

    GL11.glBindTexture( GL11.GL_TEXTURE_2D, pic.getTextureId() );
           Util.error("after bind texture");

    GL11.glTexImage2D( GL11.GL_TEXTURE_2D, 0, GL11.GL_RGBA,
                       pic.getWidth(), pic.getHeight(), 0,
      // with this image is messed up:  pic.getHeight(), pic.getWidth(), 0,
                       GL11.GL_RGBA, GL11.GL_UNSIGNED_BYTE,
                       pic.getData() );
           Util.error("after set data");

    // note:  there's some glTexStorage2D guy, we're using "older API"?
    GL30.glGenerateMipmap( GL11.GL_TEXTURE_2D );

    GL11.glTexParameteri( GL11.GL_TEXTURE_2D, GL11.GL_TEXTURE_WRAP_S,
                           GL11.GL_REPEAT );
           Util.error("after set wrap s");

    GL11.glTexParameteri( GL11.GL_TEXTURE_2D, GL11.GL_TEXTURE_WRAP_T,
                           GL11.GL_REPEAT );
           Util.error("after set wrap t");

    GL11.glTexParameteri( GL11.GL_TEXTURE_2D, GL11.GL_TEXTURE_MAG_FILTER,
                           GL11.GL_NEAREST );
           Util.error("after set mag filter");

    GL11.glTexParameteri( GL11.GL_TEXTURE_2D, GL11.GL_TEXTURE_MIN_FILTER,
                          GL11.GL_NEAREST_MIPMAP_NEAREST );
           Util.error("after set min filter");

  }

  // use the texture corresponding to pic
  public static void selectTexture( Pic pic ){

    GL13.glActiveTexture( GL13.GL_TEXTURE0 + pic.getIndex() );
           Util.error("after activate texture 0");

    GL11.glBindTexture( GL11.GL_TEXTURE_2D, pic.getTextureId() );
           Util.error("after bind texture");

    // send texture sampler as a uniform
    int loc = GL20.glGetUniformLocation( hp1, "texture" );
           Util.error("after get uniform location for texture");
//           System.out.println("got loc for texture: " + loc );
    GL20.glUniform1i( loc, pic.getIndex() );  // connect texture
           Util.error("after set value of texture");
  }

}// OpenGL
/*  a Pic instance holds pixel data
    ready to be fed into
    OpenGL as a texture
*/

import java.io.*;
import java.util.*;
import java.awt.*;
import java.awt.image.*;

import java.nio.ByteBuffer;
import java.nio.ByteOrder;

public class Pic
{
  public static final String folderName = "Pictures";

  private String name;  // name of this image within the program
  private int index;    // position in list of all Pic's of this image
  private int textureId;

  private int numRows, numCols;  // image size
  private ByteBuffer data;  // pixels extracted into rgba

  // construct this pic from raw image file
  // with given name
  public Pic( String picName, String fileName )
  {
    name = picName;

    // scan and store the image data
    try{
      FileInputStream input = new FileInputStream( new File( fileName ) );

      byte upperNumCols = (byte) input.read();
      byte lowerNumCols = (byte) input.read();
      numCols = toInt( upperNumCols, lowerNumCols );
      System.out.println("loading image file " + fileName );
      // System.out.println("got bytes for numCols " + upperNumCols + " " +
      //                        lowerNumCols + " giving numCols=" + numCols );

      byte upperNumRows = (byte) input.read();
      byte lowerNumRows = (byte) input.read();
      numRows = toInt( upperNumRows, lowerNumRows );
      // System.out.println("got bytes for numRows " + upperNumRows + " " +
      //                        lowerNumRows + " giving numRows=" + numRows );

      data = ByteBuffer.allocateDirect( 4*numRows*numCols );
      data.order( ByteOrder.nativeOrder() );

      for( int k=0; k<4*numRows*numCols; k++ )
        data.put( (byte) input.read() );

      data.rewind();

      input.close();
    }
    catch(Exception e)
    {
      System.out.println("something went wrong reading raw image file [" +
               fileName + "]" );
      e.printStackTrace();
      System.exit(1);
    }
  }// constructor

  // construct one of various procedural textures
  public Pic( int kind )
  {
    if( kind == 1 )
    {// checkboard
       int numSq = 8, numPix = 8;
       numRows = numSq*numPix;
       numCols = numSq*numPix;
       data = ByteBuffer.allocateDirect( 4*numRows*numCols );
       data.order( ByteOrder.nativeOrder() );

       boolean color1 = true, rowStart = true;
       byte r1=(byte) 255, g1=(byte) 0, b1=(byte) 0, a1=(byte) 255;
       byte r2=(byte) 0, g2=(byte) 255, b2=(byte) 0, a2=(byte) 255;

       for( int r=0; r<numRows; r++ )
       {// create row r
         for( int j=0; j<numSq; j++ )
         {// create j little squares of row r
           for( int k=0; k<numPix; k++ )
           {// create numPix columns of current color
             if( color1 )
             {
               data.put( r1 ); data.put( g1 ); data.put( b1 ); data.put( a1 );
             }
             else
             {
               data.put( r2 ); data.put( g2 ); data.put( b2 ); data.put( a2 );
             }
           }
           color1 = ! color1;  // finished square on row, switch
         }
         // finished a pixel row
         if( (r+1) % numPix == 0 )
         {// finished a block
           rowStart = !rowStart;  // switch colors for next block
           color1 = rowStart;
         }
         else
         {// in same block
           color1 = rowStart;
         }
       }

    }

    else if( kind == 2 )
    {// checkboard
      numRows = 100;
      numCols = 200;
      data = ByteBuffer.allocateDirect( 4*numRows*numCols );
      data.order( ByteOrder.nativeOrder() );

      int first = 0, last = numCols-1;
      byte r1=(byte) 255, g1=(byte) 0, b1=(byte) 0, a1=(byte) 255;
      byte r2=(byte) 0, g2=(byte) 255, b2=(byte) 0, a2=(byte) 255;


      for( int r=0; r<numRows; r++ )
      {
        for( int c=0; c<numCols; c++ )
        {
          if( c<first || last<c )
          {// draw outside color
            data.put(r1); data.put(g1); data.put(b1); data.put(a1);
          }
          else
          {// draw inside color
            data.put(r2); data.put(g2); data.put(b2); data.put(a2);
          }
        }
        // advance both
        first++;  last--;
      }

    }

  }// procedural constructor

  // convert two bytes to single int,
  // treating the signed bytes as unsigned
  private int toInt( byte upper, byte lower )
  {
    int up, low;
    if( upper < 0 )
      up = upper + 256;
    else
      up = upper;
    if( lower < 0 )
      low = lower + 256;
    else
      low = lower;
    return 256*up + low;
  }

  public int getWidth()
  {
    return numCols;
  }

  public int getHeight()
  {
    return numRows;
  }

  public int getNumber(){
    return index;
  }

  public String getName(){
    return name;
  }

  public ByteBuffer getData()
  {
    return data;
  }

  public void showData()
  {
    data.rewind();
    for( int k=0; k<4*numCols*numRows; k++ )
    {
      if( k % 4 == 0 )
        System.out.print( (k/4) + ":  " );
      System.out.print( data.get() + " " );
      if( (k+1) % 4 == 0 )
        System.out.println();
    }
  }

  // save this image sub-rectangle to given file
  public void save( String fileName, int clipX, int clipY,
                                     int clipW, int clipH )
  {
    System.out.println("save sub-image to " + fileName );

    try{
      FileOutputStream out = new FileOutputStream( new File( fileName ) );

// stub
//clipX=0;  clipY=0;  clipW=numCols;  clipH=numRows;

      // save the number of cols and rows of the sub-image
      out.write( (byte) (clipW / 256) );  out.write( (byte) (clipW % 256));
      out.write( (byte) (clipH / 256) );  out.write( (byte) (clipH % 256));

      data.rewind();

      for( int row=0; row<numRows; row++ ){
        for( int col=0; col<numCols; col++ ){
          int r = numRows-row-1;
          if( clipY<=r && r<clipY+clipH &&
              clipX<=col && col<clipX+clipW ){
            for( int m=0; m<4; m++ )
              out.write( data.get() );
          }
          else{
            // toss these 4 bytes
            for( int m=0; m<4; m++ )
              data.get();
          }
        }
      }

      out.close();
    }
    catch(Exception e){
      System.out.println("problem saving this pic");
      e.printStackTrace();
      System.exit(1);
    }
  }

  public void setIndex( int pos ){
    index = pos;
  }

  public int getIndex(){
    return index;
  }

  public void setTextureId( int x ){
    textureId = x;
  }

  public int getTextureId(){
    return textureId;
  }

  // return pixel coord x mapped into [-1,1] coords
  // used by OpenGL
  public double mapX( int x ){
    return (2.0/numCols)*x - 1;
  }

  // return pixel coord y mapped into [-1,1] coords
  // used by OpenGL
  public double mapY( int y ){
    return 1 - (2.0/numRows)*y;
  }

  public static void main(String[] args)
  {
    Pic pic = new Pic( 2 );
    System.out.println("pic has " + pic.getHeight() + " rows and " +
         pic.getWidth() + " cols");
    pic.showData();
    //pic.save( "triangle.raw" );
  }

  //*****************************************************
  // repository of all pics:

  private static ArrayList<Pic> list;  // holds all pic instances

  // change file names and add more textures here:
  public static void init(){
    list = new ArrayList<Pic>();



    // texture 1:
    addTexture( "redfire-1" );

    // texture 2:
    addTexture( "greenfire-1" );

    // texture 3:
    addTexture( "purplefire-1" );

    // texture 4:
    addTexture( "orangefire-1" );

    // texture 5:
    addTexture( "bluefire-1" );


  }

  private static void addTexture( String name ) {
    list.add( new Pic( name, Pic.folderName + "/" + name ) );
  }

  public static int size(){
    return list.size();
  }

  // provide access to any desired Pic
  public static Pic get( int index ){
    return list.get( index );
  }

}
# 3DwithTextures-jlwgl

adding texture to my 3Dscape in previous repo

## Built on Lightweight Java Game Library

### https://www.lwjgl.org/

This is a list of th needed .jars to run this on linux or MacOS

LICENSE
assimp_license.txt
build.txt
dyncall_license.txt
glfw_license.txt
khronos_license.txt
lwjgl-assimp-javadoc.jar
lwjgl-assimp-natives-linux.jar
lwjgl-assimp-natives-macos.jar
lwjgl-assimp.jar
lwjgl-glfw-javadoc.jar
lwjgl-glfw-natives-linux.jar
lwjgl-glfw-natives-macos.jar
lwjgl-glfw.jar
lwjgl-javadoc.jar
lwjgl-natives-linux.jar
lwjgl-natives-macos.jar
lwjgl-openal-javadoc.jar
lwjgl-openal-natives-linux.jar
lwjgl-openal-natives-macos.jar
lwjgl-openal.jar
lwjgl-opengl-javadoc.jar
lwjgl-opengl-natives-linux.jar
lwjgl-opengl-natives-macos.jar
lwjgl-opengl.jar
lwjgl-stb-javadoc.jar
lwjgl-stb-natives-linux.jar
lwjgl-stb-natives-macos.jar
lwjgl-stb.jar
lwjgl.jar
openal_soft_license.txt
/*
  a request simply has a kind
  and other special attributes
  sometimes needed

  Is a simple wrapper class, allow
  public instance variables

*/

public class Request {

  public String kind;
  public double amount;
  public int elapsed;  // number of frames elapsed for multi-frame request

  public Request( String knd ) {
    kind = knd;
    elapsed = 0;
  }

  public Request( String knd, double amt ) {
    kind = knd;
    amount = amt;
    elapsed = 0;
  }

}
/*  
  an instance of this class provides interface to
  a GLSL shader
*/


import org.lwjgl.glfw.*;
import org.lwjgl.opengl.*;

import java.nio.FloatBuffer;
import java.nio.ByteBuffer;
import java.nio.ByteOrder;

import java.util.Scanner;
import java.io.*;

public class Shader
{
  private int handle; 
  private String kind;  // handy user-readable version of kind of shader

  // construct and compile a Shader instance of specified kind 
  // from given String
  // (can only be called when OpenGL context is active)
  public Shader( String shaderType, String shaderCode )
  {
    if( shaderType.equals( "vertex" ) )
      handle = GL20.glCreateShader( GL20.GL_VERTEX_SHADER );
    else if( shaderType.equals( "fragment" ) )
      handle = GL20.glCreateShader( GL20.GL_FRAGMENT_SHADER );
    // for later versions, add other shader options

         Util.error("create shader");
         System.out.println("shader handle is " + handle );

    kind = shaderType;
    
    // using glShaderSource( int, CharSequence ) version of this method
    GL20.glShaderSource( handle, shaderCode );
         Util.error("after attach " + kind + " shader to handle");

    GL20.glCompileShader( handle );
         Util.error("after compile " + kind + " shader");

    String log = GL20.glGetShaderInfoLog( handle, 10000 );
    System.out.println( kind + " shader info log:\n" + log );

  }// construct a shader

  public int getHandle()
  {
    return handle;
  }

  public void delete()
  {
    GL20.glDeleteShader( handle );
         Util.error("after delete " + kind + " shader");
  }

  // read file with given name and produce a single String holding that
  // file (intended to be used for shader programs) with end-of-line
  // inserted carefully
  // Is in this class only as convenience
  public static String readFile( String fileName )
  {
    String result = "";
    try{
      Scanner input = new Scanner( new File( fileName ) );
      while( input.hasNext() )
      {
        String line = input.nextLine();
        result += line + "\n";
      }
      input.close();
    }
    catch(Exception e)
    {
      System.out.println("could not read file named [" + fileName + "]" );
      e.printStackTrace();
      System.exit(1);
    }

    return result;
  }

}
/*  a Soups instance holds
    a collection of TriSoup instances,
    one for each texture
*/

import java.util.ArrayList;

public class Soups{

  private TriSoup[] soups;

  // accumulate triangles here
  private ArrayList<Triangle> triangles;

  // build a "soups" object with
  // given number of separate images,
  // create empty soup's for each, 
  // and create empty list of triangles
  public Soups( int numTextures ){
    soups = new TriSoup[ numTextures ];
    for( int k=0; k<soups.length; k++ ){
      soups[k] = new TriSoup();
    }

    triangles = new ArrayList<Triangle>();
  }

  // go through list of bodies and add
  // the triangles for each body to 
  // cumulative list of triangles
  public void add( ArrayList<Block> bodies ){

    // accumulate all the triangles for the bodies
    for( int k=0; k<bodies.size(); k++ ){
      bodies.get(k).draw( triangles );     
    }

    // System.out.println("this soups (" + this + ") has " + triangles.size() + " triangles");
  }

  // add the triangles for given body to 
  // cumulative list of triangles
  public void add( Block body ){
    body.draw( triangles );
  }

  // go through list of Assemblies and add
  // the triangles for each block in each body
  // public void addAll( ArrayList<Assembly> list ) {
  //   for( int k=0; k<list.size(); k++ ) {
  //     add( list.get(k).getBlocks() ); 
  //   }
  // }

  // go through list of triangles and add
  // them to the soups
  public void addTris( ArrayList<Triangle> list ) {
    for( int k=0; k<list.size(); k++ ) {
      triangles.add( list.get(k) );
    }
  }

  // sort triangles into individual soup's
  // for each image
  public void sortByTexture(){
    for( int k=0; k<triangles.size(); k++ ){
      Triangle tri = triangles.get(k);
      soups[ tri.getTexture() ].add( tri );
    }
  }

  // draw all the TriSoup's
  public void draw(){

    // System.out.println("draw the soups " + this );
    // actually draw each soup
    for( int k=0; k<soups.length; k++ ){
      OpenGL.selectTexture( Pic.get(k) );
      // System.out.println("soup for texture # " + k );
      soups[ k ].draw();
    }

  }
  
  // release all the TriSoup's in this soups
  public void cleanup(){
    for( int k=0; k<soups.length; k++ ){
      soups[k].cleanup();
    }
  }

}
/*
   hold a collection of triangles,
   with OpenGL stuff needed to draw them

   draw  draws all the triangles, checking whether
         they need to be shipped to the GPU, and if so,
         it ships them first
*/

import java.util.ArrayList;
import java.nio.FloatBuffer;

import org.lwjgl.opengl.GL11;
import org.lwjgl.opengl.GL15;
import org.lwjgl.opengl.GL20;
import org.lwjgl.opengl.GL30;

public class TriSoup{

  private ArrayList<Triangle> tris;  // holds the triangles
  private boolean loaded;  // remember whether the triangles have been shipped
                           // to GPU

  private int vaoHandle;  // handle to loaded vertex array object
  private int posHandle;  // handle for positions VBO
  private int texHandle;  // handle for texture coords VBO

  public TriSoup(){
    tris = new ArrayList<Triangle>();
    loaded = false;
  }

  // add given triangle to the list
  // (and note now need loading)
  public void add( Triangle tri ){
    tris.add( tri );
    noteChange();
  }
  
  // send vertex data for
  // the triangles to GPU
  private void ship(){

    // System.out.println("start ship for " + this );
    loaded = true;

    // set up vertex array object 
    // ---------------------------------------------------------------
    vaoHandle = GL30.glGenVertexArrays();
           Util.error("after generate single vertex array");
    GL30.glBindVertexArray( vaoHandle );
           Util.error("after bind the vao");
    //           System.out.println("vao is " + vaoHandle );

    // set everything up for position VBO:
    // ---------------------------------------------------------------

    // scan tris and fill app buffer:
    for( int k=0; k<tris.size(); k++ ){
      tris.get(k).positionToBuffer();
    }
    Util.bufferFlip();

    // create vertex buffer object and its handle
    posHandle = GL15.glGenBuffers();
    //    System.out.println("have position handle " + posHandle );

    // now create GPU buffer and connect to app buffer
    GL15.glBindBuffer( GL15.GL_ARRAY_BUFFER, posHandle );
             Util.error("after bind posHandle");
    Util.sendBufferToGPU( GL15.GL_STATIC_DRAW );

    // enable the vertex array attribute
    GL20.glEnableVertexAttribArray(0);  // position
             Util.error("after enable attrib 0");

    // map index 0 to the position buffer
    GL20.glVertexAttribPointer( 0, 3, GL11.GL_FLOAT, false, 0, 0 );
             Util.error("after do position vertex attrib pointer");

    // set everything up for texCoords VBO:
    // ---------------------------------------------------------------

    // scan tris and fill app buffer:
    for( int k=0; k<tris.size(); k++ ){
      tris.get(k).texCoordsToBuffer();
    }
    Util.bufferFlip();

    // create vertex buffer object and its handle
    texHandle = GL15.glGenBuffers();
    //    System.out.println("have texCoords handle " + texHandle );

    // now create GPU buffer and connect to app buffer 
    GL15.glBindBuffer( GL15.GL_ARRAY_BUFFER, texHandle );
             Util.error("after bind posHandle");
    Util.sendBufferToGPU( GL15.GL_STATIC_DRAW );

    // enable the vertex array attribute
    GL20.glEnableVertexAttribArray(1);  // texCoords
             Util.error("after enable attrib 1");

    // map index 1 to the texCoords buffer
    GL20.glVertexAttribPointer( 1, 2, GL11.GL_FLOAT, false, 0, 0 );
             Util.error("after do texCoords vertex attrib pointer");

    // System.out.println("finished ship for " + this );

  }// ship

  public void draw(){

    if( !loaded )
      ship();

    // activate vao
    GL30.glBindVertexArray( vaoHandle );
           Util.error("after bind vao");

    // draw the triangles
    GL11.glDrawArrays( GL11.GL_TRIANGLES, 0, 3 * tris.size() );
           Util.error("after draw arrays");

  }// draw

  // a change has happened, so if is first such,
  // clean up the obsolete buffer stuff, and
  // either way set  loaded
  public void noteChange(){
    if( loaded ){
      cleanup();
    }
 
    loaded = false;
  }// noteChange

  // clean up buffer stuff due to change in
  // tris forcing another load
  public void cleanup(){

    GL30.glDeleteVertexArrays( vaoHandle );
    GL15.glDeleteBuffers( posHandle );
    GL15.glDeleteBuffers( texHandle );
  }// cleanup

  public int size(){
    return tris.size();
  }

}
import java.nio.FloatBuffer;
import java.util.Scanner;

public class Triangle {

   private Vertex a, b, c;
   private int textureNumber;

   public Triangle(Vertex aIn, Vertex bIn, Vertex cIn, int texIn) {
      a = aIn;
      b = bIn;
      c = cIn;
      textureNumber = texIn;
   }

   public Triangle(Scanner input) {
      a = new Vertex(input);
      b = new Vertex(input);
      c = new Vertex(input);
   }

   // get the data for this triangle from camera
   // and put it to pb and cb
   public void sendData(FloatBuffer pb, FloatBuffer cb) {
      a.sendData(pb, cb);
      b.sendData(pb, cb);
      c.sendData(pb, cb);
   }

   public void positionToBuffer() {
      a.positionToBuffer();
      b.positionToBuffer();
      c.positionToBuffer();
   }

   // send texCoords data for triangle to Util.appDataBuffer
   public void texCoordsToBuffer() {
      a.texCoordsToBuffer();
      b.texCoordsToBuffer();
      c.texCoordsToBuffer();
   }

   public int getTexture() {
      return textureNumber;
   }

   public String toString() {
      return a + " " + b + " " + c;
   }

}
import java.nio.FloatBuffer;
import java.util.Scanner;

public class Triple {

   private static int currentId = 0;

   private int id;
   public double x, y, z;

   public Triple(double a, double b, double c) {
      currentId++;  id = currentId;
      x = a;
      y = b;
      z = c;
   }


   public Triple( Triple other) {
      currentId++;  id = currentId;
      x = other.x;
      y = other.y;
      z = other.z;
   }

   public Triple(Scanner input) {
      currentId++;  id = currentId;
      x = input.nextDouble();
      y = input.nextDouble();
      z = input.nextDouble();
      input.nextLine();
   }


   public Triple vectorTo( Triple other )
   {
     return new Triple( other.x - x, other.y - y, other.z - z );
   }
 
   public Triple scalarProduct( double s )
   {
     return new Triple( s*x, s*y, s*z );
   }
 
   public double dotProduct( Triple other )
   {
     return x*other.x + y*other.y + z*other.z;
   }
   // return this triple minus the other
   public double dot( Triple other )
   {
     return x*other.x + y*other.y + z*other.z;
   }
   public Triple minus(Triple other) {
      return new Triple(x - other.x, y - other.y, z - other.z);
   }

   // compute dot product of this triple and
   // the given other triple
 
   // compute cross product of this triple and
   // the given other triple
   public Triple cross(Triple other) {
      return new Triple(y * other.z - z * other.y, z * other.x - x * other.z, x * other.y - y * other.x);
   }

   public Triple crossProduct( Triple other )
   {
     return new Triple( y*other.z - z*other.y,
                        z*other.x - x*other.z,
                        x*other.y - y*other.x );
   }

   // produce a normalized copy of this triple
   public Triple normalize() {
      double length = Math.sqrt(this.dot(this));
      return new Triple(x / length, y / length, z / length);
   }

     // compute the point on the line from this point s of the way
  // along the vector d
  public Triple pointOnLine( double lambda, Triple d )
  {
    return new Triple( x + lambda*d.x, y + lambda*d.y, z + lambda*d.z );
  }


    // compute point lambda of the way from this point to q
    public Triple ofTheWay( double lambda, Triple q )
    {
      return new Triple( x + lambda*(q.x-x),
                         y + lambda*(q.y-y),
                         z + lambda*(q.z-z) );
    }


    public double norm()
    {
      return Math.sqrt( x*x + y*y + z*z );
    }

    public Triple normalized()
    {
      double len = norm();
      return new Triple( x/len, y/len, z/len );
    }

  // make a new triple that is this triple plus v
  public Triple add( Triple v )
  {
    return new Triple( x+v.x, y+v.y, z+v.z );
  }

  // make a new triple that is this triple minus v
  public Triple subtract( Triple v )
  {
    return new Triple( x-v.x, y-v.y, z-v.z );
  }

  // scale this triple 
  public Triple scale( double sx, double sy, double sz ){
    return new Triple( sx*x, sy*y, sz*z );
  }

  public String toString()
  {
    return "<" + x + " " + y + " " + z + ">";
  }

  public static Triple linearComb( double alpha, Triple a,
                                   double beta, Triple b )
  {
    return new Triple( alpha*a.x + beta*b.x, 
                       alpha*a.y + beta*b.y,
                       alpha*a.z + beta*b.z );
  }

  public static Triple linearComb( double alpha, Triple a,
                                   double beta, Triple b,
                                   double gamma, Triple c )
  {
    return new Triple( alpha*a.x + beta*b.x + gamma*c.x, 
                       alpha*a.y + beta*b.y + gamma*c.y,
                       alpha*a.z + beta*b.z + gamma*c.z );
  }

  public static Triple linearComb( double alpha, Triple a,
                                   double beta, Triple b,
                                   double gamma, Triple c,
                                   double delta, Triple d )
  {
    return new Triple( alpha*a.x + beta*b.x + gamma*c.x + delta*d.x, 
                       alpha*a.y + beta*b.y + gamma*c.y + delta*d.y,
                       alpha*a.z + beta*b.z + gamma*c.z + delta*d.z );
  }

  public static double zCoordCrossProduct( Triple a, Triple b )
  {
    return a.x * b.y  - b.x * a.y;
  }

  // since Triple is immutable, makes sense to have "constants"
  // ("final" probably doesn't do anything, since no method can change)
  public final static Triple zero = new Triple(0,0,0);
  public final static Triple xAxis = new Triple(1,0,0);
  public final static Triple yAxis = new Triple(0,1,0);
  public final static Triple zAxis = new Triple(0,0,1);


   // produce homogeneous coords version of this triple
   public Vec4 toVec4() {
      return new Vec4(x, y, z);
   }

   // public String toString() {
   //    return String.format("[%10.4f %10.4f %10.4f]", x, y, z);
   // }

   public final static Triple up = new Triple(0, 0, 1);


   public void sendData(FloatBuffer buff) {
      buff.put((float) x);
      buff.put((float) y);
      buff.put((float) z);
   }
   public static void main(String[] args) {
      Triple e = new Triple(18, 20, 7), a = new Triple(9, 8, 7), b = new Triple(1, 14, 12), c = new Triple(13, 5, 17),
            p1 = new Triple(8, 3, 9), p2 = new Triple(4, 2, 6), p3 = new Triple(3, 6, 10);

      Triple eMinusA = e.minus(a), bMinusA = b.minus(a), cMinusA = c.minus(a), p1MinusE = p1.minus(e),
            p2MinusE = p2.minus(e), p3MinusE = p3.minus(e);

      System.out.println(eMinusA + " " + bMinusA + " " + cMinusA + p1MinusE + " " + p2MinusE + " " + p3MinusE + "\n");

      System.out.printf("%10.4f %10.4f %10.4f %10.4f %10.4f %10.4f\n", eMinusA.dot(eMinusA), eMinusA.dot(bMinusA),
            eMinusA.dot(cMinusA), eMinusA.dot(p1MinusE), eMinusA.dot(p2MinusE), eMinusA.dot(p3MinusE));
      System.out.printf("%10.4f %10.4f %10.4f %10.4f %10.4f %10.4f\n", bMinusA.dot(eMinusA), bMinusA.dot(bMinusA),
            bMinusA.dot(cMinusA), bMinusA.dot(p1MinusE), bMinusA.dot(p2MinusE), bMinusA.dot(p3MinusE));
      System.out.printf("%10.4f %10.4f %10.4f %10.4f %10.4f %10.4f\n", cMinusA.dot(eMinusA), cMinusA.dot(bMinusA),
            cMinusA.dot(cMinusA), cMinusA.dot(p1MinusE), cMinusA.dot(p2MinusE), cMinusA.dot(p3MinusE));

      double lambda, beta, gamma;

      lambda = -eMinusA.dot(eMinusA) / eMinusA.dot(p1MinusE);
      beta = lambda * bMinusA.dot(p1MinusE) / bMinusA.dot(bMinusA);
      gamma = lambda * cMinusA.dot(p1MinusE) / cMinusA.dot(cMinusA);
      System.out.printf("%10.4f %10.4f %10.4f\n", beta, gamma, lambda);

      lambda = -eMinusA.dot(eMinusA) / eMinusA.dot(p2MinusE);
      beta = lambda * bMinusA.dot(p2MinusE) / bMinusA.dot(bMinusA);
      gamma = lambda * cMinusA.dot(p2MinusE) / cMinusA.dot(cMinusA);
      System.out.printf("%10.4f %10.4f %10.4f\n", beta, gamma, lambda);

      lambda = -eMinusA.dot(eMinusA) / eMinusA.dot(p3MinusE);
      beta = lambda * bMinusA.dot(p3MinusE) / bMinusA.dot(bMinusA);
      gamma = lambda * cMinusA.dot(p3MinusE) / cMinusA.dot(cMinusA);
      System.out.printf("%10.4f %10.4f %10.4f\n", beta, gamma, lambda);

   }

}
/*  
   useful methods
   and constants
   that don't fit in any specific
   class
*/

import org.lwjgl.glfw.*;
import org.lwjgl.opengl.*;

import java.nio.FloatBuffer;
import java.nio.IntBuffer;
import java.nio.ByteBuffer;
import java.nio.ByteOrder;

import static org.lwjgl.glfw.Callbacks.*;
import static org.lwjgl.glfw.GLFW.*;
import static org.lwjgl.system.MemoryUtil.*;

import static org.lwjgl.opengl.GL11.*;
import static org.lwjgl.opengl.GL15.*;
import static org.lwjgl.opengl.GL20.*;

import java.util.Scanner;
import java.io.*;

import java.util.Random;
public class Util
{
  // change this to 1 if not a retinaDisplay 
  // (or probably other fancy monitors?)
  public final static int retinaDisplay = 2;  // 2 for Mac retina

  public final static double collTol = 0.0001;  

  public final static double gravityAmount = -32.0 / 900;

  public final static int gridAngle = 15;

  public static Random rng = new Random();
  // this is the one big, frequently reused app
  // buffer, direct allocated outside usual heap, apparently
  public static FloatBuffer appDataBuffer;
  private static int bufferSize = 100000000; // as big as possible

  public static void init(){
    appDataBuffer = createFloatBuffer( bufferSize );
    System.out.println("Util.init done");
  }

  // store given value a as a float in appDataBuffer
  public static void bufferPut( double a ){
    appDataBuffer.put( (float) a );
  }

  // clear appDataBuffer for next use
  public static void bufferClear(){
    appDataBuffer.clear();
  }

  // rewind appDataBuffer for next use
  public static void bufferRewind(){
    appDataBuffer.rewind();
  }

  // set limit to position and 
  // then set position to 0,
  // ready to be read
  public static void bufferFlip(){
    appDataBuffer.flip();
  }

  // connect appDataBuffer to currently active
  // GPU buffer
  public static void sendBufferToGPU( int style ){
    // System.out.println("send " + appDataBuffer.limit() + " to GPU");
    GL15.glBufferData( GL15.GL_ARRAY_BUFFER, appDataBuffer, style );
       error("after send appDataBuffer to GPU buffer");

    bufferClear();  // clear the appDataBuffer
  }


  public static void error( String message ){
    int error = glGetError();
    if( error != 0 )
    {
      System.out.println("Got OpenGL error " + error + " at " + message );
    }
  }

  // create an empty byte buffer with given space
  public static ByteBuffer createByteBuffer( int num )
  {
    // make byte buffer big enough to hold the entire bytes
    ByteBuffer bb = ByteBuffer.allocateDirect( num );
    // make sure that the order of the bytes in a single float is correct
    bb.order(ByteOrder.nativeOrder());
    return bb;
  }

  // create an empty int buffer with given space
  public static IntBuffer createIntBuffer( int num )
  {
    // make byte buffer big enough to hold the entire bytes
    ByteBuffer bb = ByteBuffer.allocateDirect( num*4 );
    // make sure that the order of the bytes in a single float is correct
    bb.order(ByteOrder.nativeOrder());
    // create int buffer from these bytes
    IntBuffer ib = bb.asIntBuffer();
    // System.out.println("new buffer has capacity of " + ib.capacity() + " limit of " + ib.limit() );
    return ib;
  }

  // create an empty float buffer with space for
  // num float's
  public static FloatBuffer createFloatBuffer( int num )
  {
    // make byte buffer big enough to hold the entire bytes
    ByteBuffer bb = ByteBuffer.allocateDirect( num*4 );
    // make sure that the order of the bytes in a single float is correct
    bb.order(ByteOrder.nativeOrder());
    // create float buffer from these bytes
    FloatBuffer fb = bb.asFloatBuffer();
    return fb;
  }

  public static void showBuffer( String message, ByteBuffer ib )
  {
    System.out.println( message );
    ib.rewind();
    while( ib.hasRemaining() )
    {
      byte x = ib.get();
      System.out.println( "next item from buffer: " + x );
    }
    ib.rewind();
  }

  public static void showBuffer( String message, IntBuffer ib )
  {
    System.out.println( message );
    ib.rewind();
    while( ib.hasRemaining() )
    {
      int x = ib.get();
      System.out.println( "next item from buffer: " + x );
    }    
    ib.rewind();
  }

  public static void showBuffer( String message, FloatBuffer ib )
  {
    System.out.println( message );
    ib.rewind();
    while( ib.hasRemaining() )
    {
      float x = ib.get();
      System.out.println( "next item from buffer: " + x );
    }
    ib.rewind();
  }

  // create a float buffer holding contents of array of doubles
  // (philosophy is to work with doubles in CPU, only convert to
  //  floats when sending to GPU)
  public static FloatBuffer arrayToBuffer( double[] array )
  {
    // make byte buffer big enough to hold the entire array bytes
    ByteBuffer bb = ByteBuffer.allocateDirect(array.length * 4);
    // make sure that the order of the bytes in a single float is correct
    bb.order(ByteOrder.nativeOrder());
    // create float buffer from these bytes
    FloatBuffer fb = bb.asFloatBuffer();
    // put the bytes of array into fb
    for( int k=0; k<array.length; k++ )
      fb.put( (float) array[k] );
    fb.rewind();

    return fb;
  }

  // create a float buffer holding contents of array of floats
  public static FloatBuffer arrayToBuffer( float[] array )
  {
    // make byte buffer big enough to hold the entire array bytes
    ByteBuffer bb = ByteBuffer.allocateDirect(array.length * 4);
    // make sure that the order of the bytes in a single float is correct
    bb.order(ByteOrder.nativeOrder());
    // create float buffer from these bytes
    FloatBuffer fb = bb.asFloatBuffer();
    // put the bytes of array into fb
    fb.put( array );
    fb.rewind();

    return fb;
  }

  // create an int buffer holding contents of array of ints
  public static IntBuffer arrayToBuffer( int[] array )
  {
    // make byte buffer big enough to hold the entire array bytes
    ByteBuffer bb = ByteBuffer.allocateDirect(array.length * 4);
    // make sure that the order of the bytes in a single float is correct
    bb.order(ByteOrder.nativeOrder());
    // create int buffer from these bytes
    IntBuffer ib = bb.asIntBuffer();
    // put the bytes of array into ib
    ib.put( array );
    ib.rewind();

    return ib;
  }

  // create a byte buffer holding contents of array of byte
  public static ByteBuffer arrayToBuffer( byte[] array )
  {
    // make byte buffer big enough to hold the entire array bytes
    ByteBuffer bb = ByteBuffer.allocateDirect( array.length );
    // make sure that the order of the bytes in a single float is correct
    bb.order(ByteOrder.nativeOrder());

    return bb;
  }

  // create a float buffer holding 4 given floats
  public static FloatBuffer makeBuffer4( float r, float g, float b, float a )
  {
    float[] array = new float[4];
    array[0]=r; array[1]=g; array[2]=b; array[3]=a;
    return arrayToBuffer( array );
  }

  // do the OpenGL calls to set up the given data as an
  // array buffer  VBO
  // with given attribute number and number of floats per item
  // and return its handle
  public static int setupVBO( FloatBuffer data, 
                               int attribIndex, int number )
  {
    int handle = GL15.glGenBuffers();
       Util.error("after generate buffer handle");
    GL15.glBindBuffer( GL15.GL_ARRAY_BUFFER, handle );
             Util.error("after bind handle");
    GL15.glBufferData( GL15.GL_ARRAY_BUFFER,
                                     data, GL15.GL_STATIC_DRAW );
             Util.error("after set data");
    GL20.glEnableVertexAttribArray( attribIndex );
             Util.error("after enable attrib " + attribIndex );
    GL20.glVertexAttribPointer( attribIndex, number, 
                                 GL11.GL_FLOAT, false, 0, 0 );
             Util.error("after do attrib pointer");

    return handle;

  }

  // do the OpenGL calls to set up the given data as an
  // array buffer  VBO
  // with given attribute number and number of ints per item
  // and return its handle
  public static int setupVBO( IntBuffer data,
                               int attribIndex, int number )
  {
    int handle = GL15.glGenBuffers();
       Util.error("after generate buffer handle");
    GL15.glBindBuffer( GL15.GL_ARRAY_BUFFER, handle );
             Util.error("after bind handle");
    GL15.glBufferData( GL15.GL_ARRAY_BUFFER,
                                     data, GL15.GL_STATIC_DRAW );
             Util.error("after set data");
    GL20.glEnableVertexAttribArray( attribIndex );
             Util.error("after enable attrib " + attribIndex );
    GL20.glVertexAttribPointer( attribIndex, number,
                                 GL11.GL_INT, false, 0, 0 );
             Util.error("after do attrib pointer");

    return handle;

  }

  // represent x using given total width and number of  decimals
  public static String nice( double x, int width, int decimals )
  {
    return String.format("%" + width + "." + decimals + "f", x );
  }

}
import java.nio.FloatBuffer;
import java.util.Scanner;

public class Vec4 {

   public double[] data;

   public Vec4() {
      data = new double[4];
   }

   public Vec4( double a, double b, double c ) {
      data = new double[4];
      data[0] = a;  data[1] = b; data[2] = c; 
      data[3] = 1;
   }

   public Vec4( Scanner input ) {
      for (int k=0; k<4; k++) {
         data[k] = input.nextDouble();
      }
      input.nextLine();
   }

   public Vec4 perspDiv() {
      Vec4 p = new Vec4();
      for (int k=0; k<4; k++) {
         p.data[k] = data[k] / data[3];
      }
      return p;
   }

   // send the x,y,z part of buffer
   public void sendData( FloatBuffer buffer ) {
      buffer.put( (float) data[0] );
      buffer.put( (float) data[1] );
      buffer.put( (float) data[2] );
   }

   public String toString() {
      String s = "[";
      for (int k=0; k<4; k++) {
         s += String.format("%12.5f", data[k] );
      }
      s += "]";
      return s;
   }

 // -----------------------

/*

   public void sendData( FloatBuffer buff ) {
      buff.put( (float) x );
      buff.put( (float) y );
      buff.put( (float) z );
   }

   // get perspective view transformation of this point in space
   // from the camera and send it
   public void sendData( FloatBuffer buff, Camera camera ) {

      Vec4 r = camera.viewTransform( this );

      buff.put( (float) r.x );
      buff.put( (float) r.y );
      buff.put( (float) r.z );
   }

   // return this triple minus the other
   public Vec4 minus( Vec4 other ) {
      return new Vec4( x - other.x, y - other.y, z - other.z );
   }

   // compute dot product of this triple and
   // the given other triple
   public double dot( Vec4 other ) {
      return x * other.x + y * other.y + z * other.z;
   }

   // compute cross product of this triple and
   // the given other triple
   public Vec4 cross( Vec4 other ) {
      return new Vec4( y*other.z - z*other.y,
                         z*other.x - x*other.z,
                         x*other.y - y*other.x );
   }

   // produce a normalized copy of this triple
   public Vec4 normalize() {
      double length = Math.sqrt( this.dot( this ) );
      return new Vec4( x / length, y / length, z / length );
   }

   public String toString() {
      return String.format("[%10.4f %10.4f %10.4f]", x, y, z );
   }

   public final static Vec4 up = new Vec4( 0, 0, 1 );

   public static void main(String[] args) {
      Vec4 e = new Vec4( 18, 20, 7 ), 
             a = new Vec4( 9, 8, 7 ),
             b = new Vec4( 1, 14, 12 ),
             c = new Vec4( 13, 5, 17 ),
             p1 = new Vec4( 8, 3, 9 ),
             p2 = new Vec4( 4, 2, 6 ),
             p3 = new Vec4( 3, 6, 10 );

      Vec4 eMinusA = e.minus(a),
             bMinusA = b.minus(a),
             cMinusA = c.minus(a),
             p1MinusE = p1.minus(e),
             p2MinusE = p2.minus(e),
             p3MinusE = p3.minus(e);

      System.out.println( eMinusA + " " + bMinusA + " " + cMinusA +
                          p1MinusE + " " + p2MinusE + " " + p3MinusE + "\n" );

      System.out.printf("%10.4f %10.4f %10.4f %10.4f %10.4f %10.4f\n", eMinusA.dot(eMinusA), eMinusA.dot(bMinusA), eMinusA.dot(cMinusA), eMinusA.dot(p1MinusE), eMinusA.dot(p2MinusE), eMinusA.dot(p3MinusE) );
      System.out.printf("%10.4f %10.4f %10.4f %10.4f %10.4f %10.4f\n", bMinusA.dot(eMinusA), bMinusA.dot(bMinusA), bMinusA.dot(cMinusA), bMinusA.dot(p1MinusE), bMinusA.dot(p2MinusE), bMinusA.dot(p3MinusE) );
      System.out.printf("%10.4f %10.4f %10.4f %10.4f %10.4f %10.4f\n", cMinusA.dot(eMinusA), cMinusA.dot(bMinusA), cMinusA.dot(cMinusA), cMinusA.dot(p1MinusE), cMinusA.dot(p2MinusE), cMinusA.dot(p3MinusE) );

      double lambda, beta, gamma;

      lambda = - eMinusA.dot( eMinusA ) / eMinusA.dot( p1MinusE );
      beta = lambda * bMinusA.dot( p1MinusE ) / bMinusA.dot( bMinusA );
      gamma = lambda * cMinusA.dot( p1MinusE ) / cMinusA.dot( cMinusA );
      System.out.printf("%10.4f %10.4f %10.4f\n", beta, gamma, lambda );

      lambda = - eMinusA.dot( eMinusA ) / eMinusA.dot( p2MinusE );
      beta = lambda * bMinusA.dot( p2MinusE ) / bMinusA.dot( bMinusA );
      gamma = lambda * cMinusA.dot( p2MinusE ) / cMinusA.dot( cMinusA );
      System.out.printf("%10.4f %10.4f %10.4f\n", beta, gamma, lambda );

      lambda = - eMinusA.dot( eMinusA ) / eMinusA.dot( p3MinusE );
      beta = lambda * bMinusA.dot( p3MinusE ) / bMinusA.dot( bMinusA );
      gamma = lambda * cMinusA.dot( p3MinusE ) / cMinusA.dot( cMinusA );
      System.out.printf("%10.4f %10.4f %10.4f\n", beta, gamma, lambda );

   }

*/

}
import java.nio.FloatBuffer;
import java.util.Scanner;

public class Vertex {

   private Triple position;
   private Triple color;
   private double x, y, z; // position
   private double s, t; // texture coordinates

   public Vertex(double xin, double yin, double zin, double sIn, double tIn) {
      x = xin;
      y = yin;
      z = zin;
      s = sIn;
      t = tIn;
   }

   public Vertex(Triple p, double sIn, double tIn) {
      x = p.x;
      y = p.y;
      z = p.z;
      s = sIn;
      t = tIn;
   }

   // send position data to Util.appDataBuffer
   public void positionToBuffer() {
      Util.bufferPut(x);
      Util.bufferPut(y);
      Util.bufferPut(z);
   }

   // send texCoords data to Util.appDataBuffer
   public void texCoordsToBuffer() {
      Util.bufferPut(s);
      Util.bufferPut(t);
   }

   public String toString() {
      return "[" + x + " " + y + " " + z + "]";
   }

   public Vertex(Triple p, Triple c) {
      position = p;
      color = c;
   }

   public Vertex(Scanner input) {
      position = new Triple(input);
      color = new Triple(input);
   }

   public void sendData(FloatBuffer pb, FloatBuffer cb) {
      position.sendData(pb);
      color.sendData(cb);
   }

}
#! /bin/bash


if [[ "$OSTYPE" == "darwin"* ]]
then
	rm *.class
	echo
	echo
	echo
	echo
	echo
	echo
	echo
	echo
	echo
	echo
	echo
	echo
	echo
	echo
	echo
	echo
	echo
	echo
	echo
	echo
	echo "------------------------------------- Syntax errors (if any):"
	echo
	javac -cp ../LWJGL/lwjgl.jar:../LWJGL/lwjgl-opengl.jar:../LWJGL/lwjgl-glfw.jar:. $1.java
	echo
	echo "------------------------------------- Runtime errors (if any):"
	echo
	java -XstartOnFirstThread -cp .:../LWJGL/lwjgl.jar:../LWJGL/lwjgl-opengl.jar:../LWJGL/lwjgl-glfw.jar:../LWJGL/lwjgl-glfw-natives-macos.jar:../LWJGL/lwjgl-natives-macos.jar:../LWJGL/lwjgl-opengl-natives-macos.jar:. -Djava.library.path=../LWJGL $1 $2 $3 $4 $5 $6 $7 $8 $9

elif [[ "$OSTYPE" == "linux-gnu" ]]
then
        rm *.class
        echo
        echo
        echo
        echo
        echo
        echo
        echo
        echo
        echo
        echo
        echo
        echo
        echo
        echo
        echo
        echo
        echo
        echo
        echo
        echo
        echo "------------------------------------- Syntax errors (if any):"
        echo
        javac -cp ../LWJGL/lwjgl.jar:../LWJGL/lwjgl-opengl.jar:../LWJGL/lwjgl-glfw.jar:. $1.java        
        echo      
        echo "------------------------------------- Runtime errors (if any):"
	echo
	java -cp .:../LWJGL/lwjgl.jar:../LWJGL/lwjgl-opengl.jar:../LWJGL/lwjgl-glfw.jar:../LWJGL/lwjgl-natives-linux.jar:../LWJGL/lwjgl-opengl-natives-linux.jar:../LWJGL/lwjgl-glfw-natives-linux.jar:. -Djava.library.path=../LWJGL $1 $2 $3 $4 $5 $6 $7 $8 $9
fi


rm *.class
3   number of triangles

-1 -0.5 -.9      triangle A
1 0 0
.5 1 .9
1 0 0
-1 0 -.9
1 0 0

0 -1 0  triangle B
0 1 0
.5 -1 0
0 1 0
-.5 1 0
0 1 0

-1 0.25 0
0 0 1
-1 0 0
0 0 1
1 -1 -.9
0 0 1

150 150 25       camera location
230 0 2       azi alt dist

35          number of blocks in the scene

groundBox   ground box for scene
50 50 -.001
0 1 0 0
50 50 0

pyraBox   
12.5 12.5 12.5      
0 1 0 0
12.5 12.5 0 

pyraBox   
12.5 12.5 12.5      
0 1 0 0
12.5 37.5 0 

pyraBox   
12.5 12.5 12.5  
0 1 0 0
37.5 12.5 0   

pyraBox   
12.5 12.5 12.5  
0 1 0 0
37.5 37.5 0   

pyraBox   
12.5 12.5 12.5  
0 1 0 0
62.5 62.5 0   

pyraBox   
12.5 12.5 12.5  
0 1 0 0
12.5 62.5 0   

pyraBox   
12.5 12.5 12.5  
0 1 0 0
62.5 12.5 0   

pyraBox   
12.5 12.5 12.5  
0 1 0 0
87.5 87.5 0

pyraBox   
12.5 12.5 12.5  
0 1 0 0
87.5 37.5 0

pyraBox   
12.5 12.5 12.5  
0 1 0 0
37.5 87.5 0   

pyraBox   
12.5 12.5 12.5  
0 1 0 0
87.5 62.5 0

pyraBox   
12.5 12.5 12.5  
0 1 0 0
62.5 87.5 0

pyraBox
12.5 12.5 12.5  
0 1 0 0
87.5 12.5 0

pyraBox
12.5 12.5 12.5  
0 1 0 0
12.5 87.5 0

pyraBox   
12.5 12.5 12.5  
0 1 0 0
37.5 62.5 0   

pyraBox   
12.5 12.5 12.5  
0 1 0 0
62.5 37.5 0   

pyraBox   
12.5 12.5 12.5  
0 1 0 0
25 25 12.5   

pyraBox   
12.5 12.5 12.5  
0 1 0 0
25 50 12.5   

pyraBox   
12.5 12.5 12.5  
0 1 0 0
50 25 12.5   

pyraBox   
12.5 12.5 12.5  
0 1 0 0
50 50 12.5   

pyraBox   
12.5 12.5 12.5  
0 1 0 0
25 75 12.5   

pyraBox   
12.5 12.5 12.5  
0 1 0 0
75 25 12.5   

pyraBox   
12.5 12.5 12.5  
0 1 0 0
50 75 12.5   

pyraBox   
12.5 12.5 12.5  
0 1 0 0
75 50 12.5   

pyraBox   
12.5 12.5 12.5  
0 1 0 0
75 25 12.5   

pyraBox   
12.5 12.5 12.5  
0 1 0 0
50 75 12.5   

pyraBox   
12.5 12.5 12.5  
0 1 0 0
75 75 12.5              //28

pyraBox   
12.5 12.5 12.5  
0 1 0 0
37.5 62.5 25   

pyraBox   
12.5 12.5 12.5  
0 1 0 0
62.5 37.5 25 

pyraBox   
12.5 12.5 12.5  
0 1 0 0
37.5 37.5 25   

pyraBox   
12.5 12.5 12.5  
0 1 0 0
62.5 62.5 25            //32

pyraBox   
12.5 12.5 12.5  
0 1 0 0
50 50 37.5   

pyraBox   
6.75 6.75 6.75
180 1 360 0
50 50 62.5

pyraBox   
6.75 6.75 6.75
0 1 360  0
50 50 62.5






pyraBox   
12.5 12.5 12.5  
0 1 0 0
-25 -25 0      

pyraBox   
12.5 12.5 12.5  
0 1 0 0
25 -25 0     


pyraBox   
12.5 12.5 12.5       
0 1 0 0
-25 25 0       


pyraBox   
50 50 50         
0 1 0 0
50 50 .002        

pyraBox   
50 50 50         
0 1 0 0
50 50 .002        

pyraBox   
50 50 50         
0 1 0 0
50 50 .002        

pyraBox   
50 50 50         
0 1 0 0
50 50 .002        

pyraBox   
50 50 50         
0 1 0 0
50 50 .002        


pyraBox   
50 50 50         scaling
0 1 0 0           rotation
50 50 0       translate
